+ [[../index.org][Main Index]]
+ [[./index.org][Problems]]

* Cyclical figurate numbers
*** Problem 61
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

|------------+----------------+-----------------------|
| Triangle   | P3,n=n(n+1)/2  | 1, 3, 6, 10, 15, ...  |
| Square     | P4,n=n2        | 1, 4, 9, 16, 25, ...  |
| Pentagonal | P5,n=n(3n−1)/2 | 1, 5, 12, 22, 35, ... |
| Hexagonal  | P6,n=n(2n−1)   | 1, 6, 15, 28, 45, ... |
| Heptagonal | P7,n=n(5n−3)/2 | 1, 7, 18, 34, 55, ... |
| Octagonal  | P8,n=n(3n−2)   | 1, 8, 21, 40, 65, ... |
|------------+----------------+-----------------------|

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first
   two digits of the next number (including the last number with the first).

2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
   pentagonal (P5,44=2882), is represented by a different number in the set.

3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.


*** Clojure
#+BEGIN_SRC clojure
  (defn nth-triangle [n] (/ (* n (inc n)) 2))
  (defn nth-square [n] (* n n))
  (defn nth-pentagonal [n] (/ (* n (- (* 3 n) 1)) 2))
  (defn nth-hexagonal [n] (* n (- (* 2 n) 1)))
  (defn nth-heptagonal [n] (/ (* n (- (* 5 n) 3)) 2))
  (defn nth-octagonal [n] (* n (- (* 3 n) 2)))

  (defn n-digit-nums-from-fn [n my-fn]
    (->> (map my-fn (rest (range)))
         (drop-while #(< % (Math/pow 10 (dec n))))
         (take-while #(< % (Math/pow 10 n)))))

  (def four-digit-from-fn (partial n-digit-nums-from-fn 4))

  (defn valid-for-next-chain? [previous next]
    (= (drop 2 (str previous))
       (take 2 (str next))))

  (require '[clojure.math.combinatorics :as combo])

  (defn thing [[first-seq second-seq third-seq fourth-seq fifth-seq sixth-seq]]
    (->> (let [first-set (set first-seq)
               second-set (set second-seq)
               third-set (set third-seq)]
           (for [a first-seq]
             (for [b second-seq
                   :when (valid-for-next-chain? a b)]
               (for [c third-seq
                     :when (valid-for-next-chain? b c)]
                 (for [d fourth-seq
                       :when (valid-for-next-chain? c d)]
                   (for [e fifth-seq
                         :when (valid-for-next-chain? d e)]
                     (for [f sixth-seq
                           :when (and (valid-for-next-chain? e f)
                                      (valid-for-next-chain? f a))]
                       [a b c d e f])))))))
         (mapcat identity)
         (mapcat identity)
         (mapcat identity)
         (mapcat identity)
         (mapcat identity)))

  (->> (combo/permutations [(four-digit-from-fn nth-triangle)
                            (four-digit-from-fn nth-square)
                            (four-digit-from-fn nth-pentagonal)
                            (four-digit-from-fn nth-hexagonal)
                            (four-digit-from-fn nth-heptagonal)
                            (four-digit-from-fn nth-octagonal)])
       (mapcat thing)
       (filter (partial not= '()))
       first
       (reduce +)) ;; => 28684


  (defn is-int? [n] (== n (int n)))

  (defn is-triangle? [n]
    (let [result (/ (- (Math/sqrt (+ (* 8 n) 1)) 1)
                    2)]
      (is-int? result)))

  (defn is-square? [n]
    (let [result (Math/sqrt n)]
      (is-int? result)))

  (defn is-pentagonal? [n]
    (let [result (/ (+ (Math/sqrt (+ (* 24 n) 1)) 1)
                    6)]
      (is-int? result)))

  (defn is-hexagonal? [n]
    (let [result (/ (+ (Math/sqrt (+ (* 8 n) 1)) 1)
                    4)]
      (is-int? result)))

  (defn is-heptagonal? [n]
    (let [result (/ (+ (Math/sqrt (+ (* 40 n) 9)) 3)
                    10)]
      (is-int? result)))

  (defn is-octagonal? [n]
    (let [result (/ (+ (Math/sqrt (+ (* 3 n) 1)) 1)
                    3)]
      (is-int? result)))
#+END_SRC

+ [[./index.org][Main Index]]

* Programming Ideas
1) Text completion using a custom dictionary.
2) Foobar3k, clojure flac player that's customizable like emacs
3) annotate properties on your code, perhaps checked as you are
   programming to give you that mega degrees of certainty.
   + Ability to limit the domain that you care about.
   + Arities?
     + How to accept multiple arities?
   + let a property be a keyword or a fn with jack-ins for the generators?
   + How do we make this something that's actually useful?
     + I.E how are properties composable.
   + hacked out idea?
   #+BEGIN_SRC clojure
     (defn
       ^{:doc "add1 takes a number and outputs that number plus 1"
         :spec {:domain [:R]
                :properties [{:property :output-number
                              :domain :N
                              :arity [:integer :integerB]
                              }]}}
       add-nums [x y]
       (+ x y))

     (defn check-spec [fn-var]
       (let [my-meta (meta fn-var)
             spec (:spec my-meta)
             properties (:properties spec)]
         ))

     (defn resolve-gen [gen-kw]
       (condp = gen-kw
         :integer 'gen-integer
         :integerB 'ayy
         ))

     (defn gen-for-arity [arity-vec]
       (map resolve-gen arity-vec))
     (gen-for-arity [:integer :integerB])

     (require '[clojure.test.check :as tc])
     (require '[clojure.test.check.generators :as gen])

     (defn resolve-test [kw]
       (condp = kw
         :output-number 'ayy
         ))

     ;;test that output is greater than input
     ;; input

     (check-spec
      #'add-nums)

   #+END_SRC
4) Codenames Clojure App
   #+BEGIN_SRC clojure
   (ns mjh.cn.core)

   (defn gen-board []
       (let [board-size 25
             assassian-count 1
             team-1-operative-count 9
             team-2-operative-count 8
             bystander-count (- board-size
                                assassian-count team-1-operative-count team-2-operative-count)
             board-vec (shuffle (take board-size (iterate inc 0)))
             assassians (subvec board-vec 0 assassian-count)

             team-1-codenames (subvec board-vec
                                       assassian-count
                                       (+ assassian-count team-1-operative-count))
             team-2-codenames (subvec board-vec
                                       (+ assassian-count team-1-operative-count)
                                       (+ assassian-count team-1-operative-count team-2-operative-count))
             bystanders-codenames (subvec board-vec
                                          (+ assassian-count team-1-operative-count team-2-operative-count)
                                          (+ assassian-count team-1-operative-count team-2-operative-count bystander-count))]
         {:team-1-codenames team-1-codenames
          :team-2-codenames team-2-codenames
          :assassians assassians
          :bystanders bystanders-codenames}))

     (def temp-board  (gen-board))
     temp-board
     temp-words

     (defn assoc-words-with-board [board words]
       (letfn [(assoc-by-kw [kw]
                 (zipmap (kw board) (map (partial nth words) (kw board)))
                 )]
         {:team-1-codenames (assoc-by-kw :team-1-codenames)
          :team-2-codenames (assoc-by-kw :team-2-codenames)
          :assassians (assoc-by-kw :assassians)
          :bystanders (assoc-by-kw :bystanders)}))







     (assoc-words-with-board temp-board temp-words)
     (def temp-words (with-open [rdr (clojure.java.io/reader "/Users/mjhamrick/Desktop/nounlist.txt")]
                       (take 25 (shuffle (line-seq rdr)))))
   #+END_SRC
5) Datomic based YNAB
   #+BEGIN_SRC clojure
     ;; account.name string
     ;; account.type [on-budget | off-budget]
     ;; account.transaction-groups ref

     ;; transaction-group.transactions ref
     ;; transaction-group.date instant

     ;; transaction.payee    ref
     ;; transaction.amount   bigdec
     ;; transaction.category ref

     ;; payee.name string


   #+END_SRC
6) Guitar Utilities
   #+BEGIN_SRC clojure
     (require '[clojure.string :as str])

     (def base-fret-board {:e []
                           :b []
                           :g []
                           :d []
                           :a []
                           :E []})

     (defn fret->string
       [pressed?]
       (if pressed?
         "|-O-"
         "|---"))

     (defn guitar-string->string [length depressed-strings]
       (str (apply str (mapcat #(fret->string (some (set depressed-strings) [%]))
                               (range length))) "|"))

     (guitar-string->string 3 [1])

     (defn add-dots [length string-seq]
       (concat string-seq
               [(str/trimr (str "  "
                                (apply str (map (fn [i]
                                                  (if (#{3 5 7 12} i)
                                                    (str "  * ")
                                                    (str "    "))) (range length)))))]))

     (defn add-string-numbers [length string-seq]
       (cons (str/trimr (str "  "
                             (apply str (map (fn [i]
                                               (str (format "%3d" i) " ")) (range length)))))
             string-seq))

     (defn fret-seq->stacked-string [fret-seq]
       (apply str (interpose \newline fret-seq)))

     (defn fret-board->string
       ([fret-board]
        (let [depressed-strings? (filter seq (vals fret-board))
              length (inc (if (seq depressed-strings?)
                            (apply max
                                   (map (partial apply max)
                                        depressed-strings?))
                            0))]
          (fret-board->string fret-board length)))
       ([fret-board base-length]
        (fret-seq->stacked-string
         (add-dots
          base-length
          (add-string-numbers
           base-length
           (map (fn [[k v]]
                  (str k (guitar-string->string base-length v))) fret-board))))))

     (fret-board->string base-fret-board)

     (fret-board->string {:e [3]
                          :b [0]
                          :g [0]
                          :d [0]
                          :a [2]
                          :E [3]})

     (def natural-notes {9  :a
                         :a  9
                         11 :b
                         :b 11
                         0  :c
                         :c  0
                         2  :d
                         :d  2
                         4  :e
                         :e  4
                         5  :f
                         :f  5
                         7  :g
                         :g  7})


     (defn note-from-num [my-num]
       (if-let [natural-note (get natural-notes (mod my-num 12))]
         [natural-note]
         [(get natural-notes (mod (dec my-num) 12)) :sharp]))


     (defn note-from-string [string-base fret]
       (let [string-base (keyword (subs (.toLowerCase (str string-base)) 1))]
         (if-let [thing (get natural-notes string-base)]
           (note-from-num (+ thing fret)))))

     (def natural-sign "♮")
     (def sharp-sign "♯")
     (def flat-sign "♭")

     (def pretty-sign-map {:natural natural-sign
                           natural-sign :natural

                           :sharp sharp-sign
                           sharp-sign :sharp

                           :flat flat-sign
                           flat-sign :flat})

     (defn pretty-up-letter [letter-kw]
       (subs (.toUpperCase (str letter-kw)) 1))

     (defn pretty-up-note [note]
       (if (= 2 (count note))
         (str (pretty-up-letter (first note)) (get pretty-sign-map (second note)))
         (str (pretty-up-letter (first note)))))


     (defn stack-string-seq [string-seq]
       (apply str (interpose "\n" string-seq)))

     (defn notes-for-fret-board [fret-board]
       (let [fret-board (into {} (filter (fn [[k v]]
                                           (seq v)) fret-board))]
         (stack-string-seq
          (map (fn [[k v]]
                 (pretty-up-note
                  (note-from-string k (first v)))) fret-board))))

     (notes-for-fret-board {:e [3]
                            :b []
                            :g [0]
                            :d [0]
                            :a [2]
                            :E [3]})

     (defn pad-stacked-string [stacked-string pad-string]
       (stack-string-seq
        (map (fn [my-str]
               (str pad-string my-str)) (.split stacked-string "\n"))))

     (pad-stacked-string (notes-for-fret-board {:e [3]
                                                :b []
                                                :g [0]
                                                :d [0]
                                                :a [2]
                                                :E [3]}) "     Note: ")

     (defn pretty-print-fretted-chord
       ([fret-board]
        (str (fret-board->string fret-board)
             "\n\n"
             (pad-stacked-string (notes-for-fret-board fret-board)
                                 "      ")))
       ([fret-board min-length]
        (str (fret-board->string fret-board min-length)
             "\n\n"
             (pad-stacked-string (notes-for-fret-board fret-board)
                                 "      "))))

     (pretty-print-fretted-chord {:e [2]
                                  :b [3]
                                  :g [2]
                                  :d [0]
                                  :a []
                                  :E []})

     (pretty-print-fretted-chord {:e []
                                  :b [10]
                                  :g [11]>
                                  :d [11]
                                  :a [0]
                                  :E []})

     (pretty-print-fretted-chord {:e []
                                  :b [9]
                                  :g [9]
                                  :d [9]
                                  :a [0]
                                  :E []})

     (pretty-print-fretted-chord {:e []
                                  :b [5]
                                  :g [5]
                                  :d [4]
                                  :a []
                                  :E [3]})

     (pretty-print-fretted-chord {:e []
                                  :b [3]
                                  :g [4]
                                  :d [5]
                                  :a []
                                  :E []})

     (pretty-print-fretted-chord {:e [5]
                                  :b [3]
                                  :g [4]
                                  :d [4]
                                  :a []
                                  :E []})

     (let [random-string (rand-nth [:e :b :g :d :a])
           random-fret [(rand-int 5)]
           random-note {random-string random-fret}]
       (str (fret-board->string (merge base-fret-board
                                       random-note)
                                10)
            "\n\n      "
            (pretty-up-note
             (note-from-string random-string (first random-fret)))))xo
   #+END_SRC

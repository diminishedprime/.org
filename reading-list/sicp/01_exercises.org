     1. [ ]
     2. [ ]
     3. [ ]
     4. [ ]
     5. [ ]
     6. [ ]
     7. [ ]
     8. [ ]
     9. [ ]
     10. [X] Random function
         #+BEGIN_SRC scheme
           ;;       / n if n < 3
           ;; f(n) |
           ;;       \ f(n-1) + 2f(n-2)+3f(n-3) if n >=3

           ;; Recursive Process
           (define (f n)
             (cond ((< n 3) n)
                   (else (+ (f (- n 1))
                            (* 2 (f (- n 2)))
                            (* 3 (f (- n 3)))))))
           (f 4)

           ;; Iterative Process
           (define (f n)
             (define (iter a b c count)
               (if (= 0 count)
                   a
                   (iter b c (+ c
                                (* 2 b)
                                (* 3 a))
                         (- count 1))))
             (iter 0 1 2 n))
           (f 4)
         #+END_SRC
     11. [X] Pascal Triangle
         #+BEGIN_SRC scheme
           (define (pascal-triangle row col)
             (cond ((> col row) 0)
                   ((< col 0) 0)
                   ((= col 1) 1)
                   (else (+ (pascal-triangle (- row 1) (- col 1))
                            (pascal-triangle (- row 1) col)))))
           (pascal-triangle 5 3)
         #+END_SRC
     12. [ ] Proofs are hard.
     13. [X] Tree suck to type out.
         + Just look at the solution via the link above.
     14. [X] Recursive Sin(x)
         #+BEGIN_SRC scheme
           (define (cube x) (* x x x))
           (define (p x)
             (- (* 3 x)
                (* 4 (cube x))))
           (define (sine angle)
             (if (not (> (abs angle) .1))
                 angle
                 (p (sine (/ angle 3.0)))))

           (sine 12.15)
           (p (sine (/ 12.15 3)))
           (p (p (sine (/ 4.05 3))))
           (p (p (p (sine (/ 1.3499999999999999 3)))))
           (p (p (p (p (sine (/ .44999999999999996 3))))))
           (p (p (p (p (p (sine (/ .15 3)))))))
           (p (p (p (p (p (sine .05))))))

           ;; p is applied 5 times. the order of growth is O(log 3) since the
           ;; number is decreased by a constant factor of 3 each time it is
           ;; evaluated.
         #+END_SRC
     15. [X] Iterative log(n) fast-exp
         #+BEGIN_SRC scheme
           (define (fast-exp b n)
             (define (iter a b n)
               (cond ((= n 0) a)
                     ((even? n) (iter a (square b) (/ n 2)))
                     (else (iter (* a b) b (- n 1)))))
             (iter 1 b n))
           (fast-exp 2 1000)
         #+END_SRC
     16. [X] Fast multiplication through recursive adding
         #+BEGIN_SRC scheme
           (define (fast-mult b n)
             (define (halve x)
               (/ x 2))
             (define (double x)
               (+ x x))
             (cond ((= n 0) 0)
                   ((even? b) (double (* n (halve b))))
                   (else (+ n (* n (- b 1))))))
           (fast-mult 100 100)
         #+END_SRC
     17. [X] Fast multiplication through iterative adding
         #+BEGIN_SRC scheme
           (define (* a b)
             (define (double x) (+ x x))
             (define (halve x) (floor (/ x 2)))
             (define (iter accumulator a b)
               (cond ((= b 0) accumulator)
                     ((even? b) (iter accumulator (double a) (halve b)))
                     (else (iter (+ accumulator a) a (- b 1)))))
             (iter 0 a b))
           (* 100 100)
         #+END_SRC
     18. [X] Fib in log steps using some linear algebra magic.
         #+BEGIN_SRC scheme
           (define (fib n)
             (define (even? x)
               (= (remainder x 2) 0))
             (define (fib-iter p-acc q-acc p q n)
               (cond ((= n 0) q-acc)
                     ((even? n) (fib-iter
                                 p-acc
                                 q-acc
                                 (+ (* p p) (* q q))
                                 (+ (* 2 p q) (* q q))
                                 (/ n 2)))
                     (else (fib-iter
                            (+ (* p p-acc) (* q q-acc))
                            (+ (* p q-acc) (* q p-acc) (* q q-acc))
                            p
                            q
                            (- n 1)))))
             (fib-iter 1 0 0 1 n))

           (fib 0)
           (fib 1)
           (fib 2)
           (fib 5)
           (fib 6)
           (fib 19)
           (fib 20)
           (fib 100)
         #+END_SRC
     19. [X] Normal v. applicative order for euclid's gcd.
         + I don't want to actually do the exercise, but from looking
           at the solution I can see that the applicative order
           evaluation does far fewer remainder operations because it
           doesn't have to unnecessarily substitute down.
     20. [X] Smallest divisor of some numbers
         #+BEGIN_SRC scheme
           (define (smallest-divisor n)
             (define (divides? a b)
               (= (remainder b a) 0))
             (define (find-divisor n test-divisor)
               (cond ((> (square test-divisor) n) n)
                     ((divides? test-divisor n) test-divisor)
                     (else (find-divisor n (+ test-divisor 1)))))
             (find-divisor n 2))

           (smallest-divisor 199) ;; => 199
           (smallest-divisor 1999) ;; => 1999
           (smallest-divisor 19999) ;; => 7
         #+END_SRC
     21. [ ] Time of algos
         + It seems like I can't do this because my scheme
           implementation doesn't have a runtime procedure. :(
     22. [ ]
     23. [ ]
     24. [ ]
     25. [ ]
     26. [ ] Carmichael Numbers
     27. [ ]
     28. [X] Simpson's Rule for Integrals
         #+BEGIN_SRC scheme
           (define (sum term a next b)
             (if (> a b)
                 0
                 (+ (term a)
                    (sum term (next a) next b))))

           (define (simpson f a b n)
             (define (inc a) (+ a 1))
             (define h (/ (- b a) n))
             (define (yk k) (f (+ a (* h k))))
             (define (simpson-term k)
               (* (cond ((or (= k 0) (= k n)) 1)
                        ((odd? k) 4)
                        (else 2))
                  (yk k)))
             (* (/ h 3) (sum simpson-term 0 inc n)))

           (simpson (lambda(x)(* x x x)) 0 1 2)
         #+END_SRC
     29. [ ] Sum as an iterative recursion
     30. [ ] product as iterative and linear recursions.
     31. [ ] Sum and product are even more general!
     32. [ ] Filtering on the more general idea.
     33. [X] Perverse evaluator questions
         #+BEGIN_SRC scheme
           (define (f g) (g 2))
           ;; If we try apply to f to f, the following will happen.
           ;; (f f)
           ;; (f 2)
           ;; (2 2) which is an error.
         #+END_SRC

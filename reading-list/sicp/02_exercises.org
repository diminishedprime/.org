* Chapter 2 Exercises
1. [ ]
2. [X] Exercise 2.2
   + Consider the problem of representing line segments in a plane. Each segment
     is represented as a pair of points: a starting point and an ending point.
     Define a constructor make-segment and selectors start-segment and
     end-segment that define the representation of segments in terms of points.
     Furthermore, a point can be represented as a pair of numbers: the x
     coordinate and the y coordinate. Accordingly, specify a constructor
     make-point and selectors x-point and y-point that define this
     representation. Finally, using your selectors and constructors, define a
     procedure midpoint-segment that takes a line segment as argument and
     returns its midpoint (the point whose coordinates are the average of the
     coordinates of the endpoints). To try your procedures, you’ll need a way to
     print points:
     #+BEGIN_SRC scheme
       (define make-point
         (lambda (x y)
           (list x y)))

       (define x-point
         (lambda (point)
           (car point)))

       (define y-point
         (lambda (point)
           (car (cdr point))))

       (define make-segment
         (lambda (point-1 point-2)
           (list point-1 point-2)))

       (define start-segment
         (lambda (segment)
           (car segment)))

       (define end-segment
         (lambda (segment)
           (car (cdr segment))))

       (define (print-point p)
         (newline)
         (display "(")
         (display (x-point p))
         (display ",")
         (display (y-point p))
         (display ")"))

       (define average
         (lambda (a b)
           (/ (+ a b) 2)))

       (define midpoint-segment
         (lambda (segment)
           (let ((point-1 (start-segment segment))
                 (point-2 (end-segment segment)))
             (let ((x1 (x-point point-1))
                   (x2 (x-point point-2))
                   (y1 (y-point point-1))
                   (y2 (y-point point-2)))
               (make-point (average x1 x2)
                           (average y1 y2))))))


       (make-point 1 2)

       (x-point (make-point 1 2))

       (y-point (make-point 1 2))

       (make-segment (make-point 1 2)
                     (make-point 2 3))

       (start-segment (make-segment (make-point 1 2)
                                    (make-point 2 3)))

       (end-segment (make-segment (make-point 1 2)
                                  (make-point 2 3)))

       (midpoint-segment (make-segment (make-point 1 2)
                                       (make-point 2 3)))
     #+END_SRC
3. [X] Exercise 2.3
   + Implement a representation for rectangles in a plane. (Hint: You may want
     to make use of Exercise 2.2.) In terms of your constructors and selectors,
     create procedures that compute the perimeter and the area of a given
     rectangle. Now implement a different representation for rectangles. Can you
     design your system with suitable abstraction barriers, so that the same
     perimeter and area procedures will work using either representation?
     #+BEGIN_SRC scheme
       (define make-rectangle
         (lambda (top-left bottom-right)
           (list top-left bottom-right)))

       (define top-left
         (lambda (rect)
           (car rect)))

       (define bottom-right
         (lambda (rect)
           (car (cdr rect))))

       (define perimeter-rect
         (lambda (rect)
           (let ((top-left (top-left rect))
                 (bottom-right (bottom-right rect)))
             (let ((x-left (x-point top-left))
                   (x-right (x-point bottom-right))
                   (y-top (y-point top-left))
                   (y-bottom (y-point bottom-right)))
               (let ((height (- y-top y-bottom))
                     (width (- x-right x-left)))
                 (+ (* 2 height)
                    (* 2 width)))))))

       (define area-rect
         (lambda (rect)
           (let ((top-left (top-left rect))
                 (bottom-right (bottom-right rect)))
             (let ((x-left (x-point top-left))
                   (x-right (x-point bottom-right))
                   (y-top (y-point top-left))
                   (y-bottom (y-point bottom-right)))
               (let ((height (- y-top y-bottom))
                     (width (- x-right x-left)))
                 (* height width))))))


       (make-rectangle (make-point 2 2)
                       (make-point 1 1))

       (top-left (make-rectangle (make-point 2 2)
                                 (make-point 1 1)))

       (bottom-right (make-rectangle (make-point 2 2)
                                     (make-point 1 1)))


       (perimeter-rect (make-rectangle (make-point -3 2)
                                       (make-point 3 -8)))

       (area-rect (make-rectangle (make-point -3 2)
                                  (make-point 3 -8)))
     #+END_SRC
4. [X] Exercise 2.4
   + Here is an alternative procedural representa- tion of pairs. For this
     representation, verify that (car (cons x y)) yields x for any objects x and
     y.
     #+BEGIN_SRC scheme
       (define (cons x y)
         (lambda (m) (m x y)))
       (define (car z)
         (z (lambda (p q) p)))

       (let ((a 1)
             (b 2))
         (= (car (cons a b))
            a)) ;; => #t
     #+END_SRC
   + What is the corresponding definition of cdr? (Hint: To verify that this
     works, make use of the substitution model of Section 1.1.5.)
     #+BEGIN_SRC scheme
       (define (cdr z)
         (z (lambda (p q) q)))

       (let ((a 1)
             (b 2))
         (= (cdr (cons a b))
            b))
     #+END_SRC
5. [X] Exercise 2.5
   + Show that we can represent pairs of non-negative integers using only
     numbers and arithmetic operations if we represent the pair a and b as the
     integer that is the product 2^a 3^b. Give the corresponding definitions of
     the procedures cons, car, and cdr.
     #+BEGIN_SRC scheme
       ;; I totally had to look this up online.
       (define (cons x y)
         (* (expt 2 x)
            (expt 3 y)))

       (define (log-reduce n base)
         (cond ((not (zero? (remainder n base))) 0)
               (else (+ (log-reduce (/ n base) base) 1))))

       (define (car z)
         (log-reduce z 2))

       (define (cdr z)
         (log-reduce z 3))

       (define test-pair (cons 11 7))
       (car test-pair) ;; => 11
       (cdr test-pair) ;; => 7
     #+END_SRC
6. [X] Exercise 2.6
   + In case representing pairs as procedures wasn’t mind-boggling enough,
     consider that, in a language that can manipulate procedures, we can get by
     without numbers (at least insofar as nonnegative integers are concerned) by
     implementing 0 and the operation of adding 1 as
     #+BEGIN_SRC scheme
       (define zero
         (lambda (f)
           (lambda (x) x)))

       (define (add-1 n)
         (lambda (f)
           (lambda (x)
             (f ((n f) x)))))
     #+END_SRC
     + This representation is known as Church numerals, after its inventor,
       Alonzo Church, the logician who invented the λ-calculus.
     + Define one and two directly (not in terms of zero and add- 1). (Hint: Use
       substitution to evaluate (add-1 zero)). Give a direct definition of the
       addition procedure + (not in terms of repeated application of add-1).
       #+BEGIN_SRC scheme
         (define one
           (lambda (f)
             (lambda (x)
               (f x))))

         (define two
           (lambda (f)
             (lambda (x)
               (f (f x)))))

         ;; This is basic church encoding. If you put some effort in, you can see that
         ;; the composition of two church numbers are the same as addition. That's what
         ;; leads us to this result.

         (define (add a b)
           (lambda (f)
             (lambda (x)
               ((a f) ((b f) x)))))

       #+END_SRC

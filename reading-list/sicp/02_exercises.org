* Chapter 2 Exercises [78%]
1. [ ] Exercise 2.1
2. [X] Exercise 2.2
    #+BEGIN_SRC scheme
      ;; Consider the problem of representing line segments in a plane. Each segment
      ;; is represented as a pair of points: a starting point and an ending point.
      ;; Define a constructor make-segment and selectors start-segment and end-segment
      ;; that define the representation of segments in terms of points. Furthermore, a
      ;; point can be represented as a pair of numbers: the x coordinate and the y
      ;; coordinate. Accordingly, specify a constructor make-point and selectors
      ;; x-point and y-point that define this representation. Finally, using your
      ;; selectors and constructors, define a procedure midpoint-segment that takes a
      ;; line segment as argument and returns its midpoint (the point whose
      ;; coordinates are the average of the coordinates of the endpoints). To try your
      ;; procedures, you’ll need a way to print points:

      (define make-point
        (lambda (x y)
          (list x y)))

      (define x-point
        (lambda (point)
          (car point)))

      (define y-point
        (lambda (point)
          (car (cdr point))))

      (define make-segment
        (lambda (point-1 point-2)
          (list point-1 point-2)))

      (define start-segment
        (lambda (segment)
          (car segment)))

      (define end-segment
        (lambda (segment)
          (car (cdr segment))))

      (define (print-point p)
        (newline)
        (display "(")
        (display (x-point p))
        (display ",")
        (display (y-point p))
        (display ")"))

      (define average
        (lambda (a b)
          (/ (+ a b) 2)))

      (define midpoint-segment
        (lambda (segment)
          (let ((point-1 (start-segment segment))
                (point-2 (end-segment segment)))
            (let ((x1 (x-point point-1))
                  (x2 (x-point point-2))
                  (y1 (y-point point-1))
                  (y2 (y-point point-2)))
              (make-point (average x1 x2)
                          (average y1 y2))))))


      (make-point 1 2)

      (x-point (make-point 1 2))

      (y-point (make-point 1 2))

      (make-segment (make-point 1 2)
                    (make-point 2 3))

      (start-segment (make-segment (make-point 1 2)
                                   (make-point 2 3)))

      (end-segment (make-segment (make-point 1 2)
                                 (make-point 2 3)))

      (midpoint-segment (make-segment (make-point 1 2)
                                      (make-point 2 3)))
     #+END_SRC
3. [X] Exercise 2.3
   #+BEGIN_SRC scheme
     ;; Implement a representation for rectangles in a plane. (Hint: You may want to
     ;; make use of Exercise 2.2.) In terms of your constructors and selectors,
     ;; create procedures that compute the perimeter and the area of a given
     ;; rectangle. Now implement a different representation for rectangles. Can you
     ;; design your system with suitable abstraction barriers, so that the same
     ;; perimeter and area procedures will work using either representation?

     (define make-rectangle
       (lambda (top-left bottom-right)
         (list top-left bottom-right)))

     (define top-left
       (lambda (rect)
         (car rect)))

     (define bottom-right
       (lambda (rect)
         (car (cdr rect))))

     (define perimeter-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (+ (* 2 height)
                  (* 2 width)))))))

     (define area-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (* height width))))))


     (make-rectangle (make-point 2 2)
                     (make-point 1 1))

     (top-left (make-rectangle (make-point 2 2)
                               (make-point 1 1)))

     (bottom-right (make-rectangle (make-point 2 2)
                                   (make-point 1 1)))


     (perimeter-rect (make-rectangle (make-point -3 2)
                                     (make-point 3 -8)))

     (area-rect (make-rectangle (make-point -3 2)
                                (make-point 3 -8)))
     #+END_SRC
4. [X] Exercise 2.4
   #+BEGIN_SRC scheme
     ;; Here is an alternative procedural representa- tion of pairs. For this
     ;; representation, verify that (car (cons x y)) yields x for any objects x and
     ;; y.

     (define (cons x y)
       (lambda (m) (m x y)))
              (define (car z)
                (z (lambda (p q) p)))

              (let ((a 1)
                    (b 2))
                (= (car (cons a b))
                   a)) ;; => #t

     ;; What is the corresponding definition of cdr? (Hint: To verify that this
     ;; works, make use of the substitution model of Section 1.1.5.)
     (define (cdr z)
       (z (lambda (p q) q)))

     (let ((a 1)
           (b 2))
       (= (cdr (cons a b))
          b))
     #+END_SRC
5. [X] Exercise 2.5
   #+BEGIN_SRC scheme
     ;; Show that we can represent pairs of non-negative integers using only numbers
     ;; and arithmetic operations if we represent the pair a and b as the integer
     ;; that is the product 2^a 3^b. Give the corresponding definitions of the
     ;; procedures cons, car, and cdr. I totally had to look this up online.
       (define (cons x y)
         (* (expt 2 x)
            (expt 3 y)))

       (define (log-reduce n base)
         (cond ((not (zero? (remainder n base))) 0)
               (else (+ (log-reduce (/ n base) base) 1))))

       (define (car z)
         (log-reduce z 2))

       (define (cdr z)
         (log-reduce z 3))

       (define test-pair (cons 11 7))
       (car test-pair) ;; => 11
       (cdr test-pair) ;; => 7
     #+END_SRC
6. [X] Exercise 2.6
   #+BEGIN_SRC scheme
     ;; In case representing pairs as procedures wasn’t mind-boggling enough,
     ;; consider that, in a language that can manipulate procedures, we can get by
     ;; without numbers (at least insofar as nonnegative integers are concerned) by
     ;; implementing 0 and the operation of adding 1 as
     (define zero
       (lambda (f)
         (lambda (x) x)))

     (define (add-1 n)
       (lambda (f)
         (lambda (x)
           (f ((n f) x)))))

     ;; This representation is known as Church numerals, after its inventor, Alonzo
     ;; Church, the logician who invented the λ-calculus.

     ;; Define one and two directly (not in terms of zero and add- 1). (Hint: Use
     ;; substitution to evaluate (add-1 zero)). Give a direct definition of the
     ;; addition procedure + (not in terms of repeated application of add-1).

     (define one
       (lambda (f)
         (lambda (x)
           (f x))))

     (define two
       (lambda (f)
         (lambda (x)
           (f (f x)))))

     ;; This is basic church encoding. If you put some effort in, you can see that
     ;; the composition of two church numbers are the same as addition. That's what
     ;; leads us to this result.

     (define (add a b)
       (lambda (f)
         (lambda (x)
           ((a f) ((b f) x)))))

       #+END_SRC
7. [X] Exercise 2.7
   #+BEGIN_SRC scheme
     ;; Setup
     (define (add-interval x y)
       (make-interval (+ (lower-bound x) (lower-bound y))
                      (+ (upper-bound x) (upper-bound y))))

     (define (mul-interval x y)
       (let ((p1 (* (lower-bound x) (lower-bound y)))
             (p2 (* (lower-bound x) (upper-bound y)))
             (p3 (* (upper-bound x) (lower-bound y)))
             (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))

     (define (div-interval x y)
       (mul-interval x
                     (make-interval (/ 1.0 (upper-bound y))
                                    (/ 1.0 (lower-bound y)))))

     ;; Alyssa's program is incomplete because she has not specified the
     ;; implementation of the interval abstraction. Here is a definition of the
     ;; interval constructor:

     (define (make-interval a b) (cons a b))

     ;; Define selectors upper-bound and lower-bound to complete the implementation.

     (define (make-interval a b) (cons a b))

     (define upper-bound
       (lambda (interval)
         (cdr interval)))

     (define lower-bound
       (lambda (interval)
         (car interval)))
   #+END_SRC
8. [X] Exercise 2.8
   #+BEGIN_SRC scheme
     ;; Using reasoning analogous to Alyssa's, describe how the difference of two
     ;; intervals may be computed. Define a corresponding subtraction procedure,
     ;; called sub-interval.
     (define sub-interval
       (lambda (x y)
         (let ((s1 (- (lower-bound x) (lower-bound y)))
               (s2 (- (lower-bound x) (upper-bound y)))
               (s3 (- (upper-bound x) (lower-bound y)))
               (s4 (- (upper-bound x) (upper-bound y))))
           (make-interval (min s1 s2 s3 s4)
                          (max s1 s2 s3 s4)))))


   #+END_SRC
9. [X] Exercise 2.9
   #+BEGIN_SRC scheme
     ;; The width of an interval is half of the difference between its upper and
     ;; lower bounds. The width is a measure of the uncertainty of the number
     ;; specified by the interval. For some arithmetic operations the width of the
     ;; result of combining two intervals is a function only of the widths of the
     ;; argument intervals, whereas for others the width of the combination is not a
     ;; function of the widths of the argument intervals. Show that the width of the
     ;; sum (or difference) of two intervals is a function only of the widths of the
     ;; intervals being added (or subtracted). Give examples to show that this is not
     ;; true for multiplication or division.

     (define interval-width
       (lambda (interval)
         (let ((difference (abs (- (lower-bound interval)
                                   (upper-bound interval)))))
           (/ difference 2))))

     (define same-width?
       (lambda (operation fn x y)
         (let ((width-x (interval-width x))
               (width-y (interval-width y))
               (width-res (interval-width (operation x y))))
           (= width-res (fn width-x width-y)))))

     (same-width? add-interval
                  +
                  (make-interval 3 4)
                  (make-interval 8 9))

     ;; add and subtract interval's width are both a function of +. Multiply and
     ;; divide return intervals are made by getting the minimum and the maximum of
     ;; the varients of the intervals. This means there is a loss of information
     ;; between the first and second intervals, and that information is necessary in
     ;; order to have a function that relates the two widths to the resulting width.
   #+END_SRC
10. [X] Exercise 2.10
    #+BEGIN_SRC scheme
      ;; Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
      ;; comments that it is not clear what it means to divide by an interval that
      ;; spans zero. Modify Alyssa's code to check for this condition and to signal an
      ;; error if it occurs.

      (define spans-zero?
        (lambda (x)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x)))
            (< (* x1 x2) 0))))

      (define (div-interval x y)
        (if (or (spans-zero? x)
                (spans-zero? y))
            'something-went-horribly-wrong
            (mul-interval x
                          (make-interval (/ 1.0 (upper-bound y))
                                         (/ 1.0 (lower-bound y))))))

      (list (div-interval (make-interval 3 4)
                          (make-interval -3 4))
            (div-interval (make-interval 3 4)
                          (make-interval -4 -3)))

    #+END_SRC
11. [X] Exercise 2.11
    #+BEGIN_SRC scheme
      ;; In passing, Ben also cryptically comments: ``By testing the signs of the
      ;; endpoints of the intervals, it is possible to break mul-interval into nine
      ;; cases, only one of which requires more than two multiplications.'' Rewrite
      ;; this procedure using Ben's suggestion.

      (define interval-makeup
        (lambda (interval)
          (let ((x1 (lower-bound interval))
                (x2 (upper-bound interval)))
            (cond
             ((and (< x1 0) (< x2 0)) -1)
             ((and (< x1 0) (< x2 0)) 0)
             (else 1)))))

      (define mul-interval
        (lambda (x y)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x))
                (y1 (lower-bound y))
                (y2 (lower-bound y))
                (sign-x (interval-makeup x))
                (sign-y (interval-makeup y)))
            (cond
             ((< sign-x 0) (cond
                            ;; - - - -
                            ((< sign-y 0) (make-interval (* x2 y2)
                                                         (* x1 y1)))
                            ;; - - - +
                            ((= sign-y 0) (make-interval (* x1 y2)
                                                         (* x1 y1)))
                            ;; - - + +
                            (else (make-interval (* x1 y2)
                                                 (* x2 y1)))))
             ((= sign 0) (cond
                          ;; - + - -
                          ((< sign-y 0) (make-interval (* x2 y1)
                                                       (* x1 y1)))
                          ;; - + - +
                          ((= sign-y 0) (make-interval (min (* x1 y2)
                                                            (* x2 y1))
                                                       (max (* x1 y1)
                                                            (* x2 y2))))
                          (else (make-interval (* x1 y2)
                                               (* x2 y2)))))
             (else (cond
                    ;; + + - -
                    ((< sign-y 0) (make-interval (* x2 y1)
                                                 (* x1 y2)))
                    ((= sign-y 0) (make-interval (* x2 y1)
                                                 (* x2 y2)))
                    (else (make-interval (* x1 y1)
                                         (* x2 y2)))))))))

      ;; After debugging her program, Alyssa shows it to a potential user, who
      ;; complains that her program solves the wrong problem. He wants a program that
      ;; can deal with numbers represented as a center value and an additive
      ;; tolerance; for example, he wants to work with intervals such as 3.5± 0.15
      ;; rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem
      ;; by supplying an alternate constructor and alternate selectors:

      (define (make-center-width c w)
        (make-interval (- c w) (+ c w)))
      (define (center i)
        (/ (+ (lower-bound i) (upper-bound i)) 2))
      (define (width i)
        (/ (- (upper-bound i) (lower-bound i)) 2))

      ;; Unfortunately, most of Alyssa's users are engineers. Real engineering
      ;; situations usually involve measurements with only a small uncertainty,
      ;; measured as the ratio of the width of the interval to the midpoint of the
      ;; interval. Engineers usually specify percentage tolerances on the parameters
      ;; of devices, as in the resistor specifications given earlier.
    #+END_SRC
12. [X] Exercise 2.12
    #+BEGIN_SRC scheme
      ;; Define a constructor make-center-percent that takes a center and a percentage
      ;; tolerance and produces the desired interval. You must also define a selector
      ;; percent that produces the percentage tolerance for a given interval. The
      ;; center selector is the same as the one shown above.

      (define make-center-percent
        (lambda (center tolerance)
          (let ((diff (* center tolerance)))
            (let ((lower (- center tolerance))
                  (upper (+ center tolerance)))
              (make-interval lower upper)))))

      (define percent
        (lambda (interval)
          (let ((width (interval-width interval))
                (center (/ (+ (upper-bound interval)
                              (lower-bound interval)) 2))
                )
            (/ center width))))
    #+END_SRC
13. [ ]
14. [ ]
15. [ ]
16. [ ]
17. [X] Exercise 2.17
    #+BEGIN_SRC scheme
      ;; Define a procedure last-pair that returns the list that contains only the
      ;; last element of a given (nonempty) list:

      (define last-pair
        (lambda (l)
          (let ((len (length l)))
            (cond
             ((= len 1) l)
             (else (last-pair (cdr l)))))))

      (equal? (list 4) (last-pair (list 1 2 3 4)))
      (equal? (list 34) (last-pair (list 23 72 149 34)))
    #+END_SRC
18. [X] Exercise 2.18
    #+BEGIN_SRC scheme
      ;; Define a procedure reverse that takes a list as argument and returns a list
      ;; of the same elements in reverse order:

      (define (append list1 list2)
        (if (null? list1)
            list2
            (cons (car list1) (append (cdr list1) list2))))

      (define reverse
        (lambda (l)
          (cond
           ((null? l) l)
           (else (append (reverse (cdr l))
                         (list (car l)))))))

      (equal? (list 25 16 9 4 1)
              (reverse (list 1 4 9 16 25)))
    #+END_SRC
19. [X] Exercise 2.19
    #+BEGIN_SRC scheme
      ;; Consider the change-counting program of section 1.2.2. It would be nice to be
      ;; able to easily change the currency used by the program, so that we could
      ;; compute the number of ways to change a British pound, for example. As the
      ;; program is written, the knowledge of the currency is distributed partly into
      ;; the procedure first-denomination and partly into the procedure count-change
      ;; (which knows that there are five kinds of U.S. coins). It would be nicer to
      ;; be able to supply a list of coins to be used for making change.

      ;; We want to rewrite the procedure cc so that its second argument is a list of
      ;; the values of the coins to use rather than an integer specifying which coins
      ;; to use. We could then have lists that defined each kind of currency:

      (define us-coins (list 50 25 10 5 1))
      (define uk-coins (list 100 50 20 10 5 2 1 0.5))

      ;; We could then call cc as follows:

      ;; (cc 100 us-coins)

      ;; To do this will require changing the program cc somewhat. It will still have
      ;; the same form, but it will access its second argument differently, as
      ;; follows:

      (define first-denomination
        (lambda (coin-values)
          (car coin-values)))

      (define no-more?
        (lambda (coin-values)
          (null? coin-values)))

      (define except-first-denomination
        (lambda (coin-values)
          (cdr coin-values)))

      (define (cc amount coin-values)
        (cond ((= amount 0) 1)
              ((or (< amount 0) (no-more? coin-values)) 0)
              (else
               (+ (cc amount
                      (except-first-denomination coin-values))
                  (cc (- amount
                         (first-denomination coin-values))
                      coin-values)))))

      ;; Define the procedures first-denomination, except-first-denomination, and
      ;; no-more? in terms of primitive operations on list structures. Does the order
      ;; of the list coin-values affect the answer produced by cc? Why or why not?

      (cc 100 us-coins)

      ;; The answer is independent on the order of the coins. See this for an example

      (equal? (cc 25 uk-coins)
              (cc 25 (reverse uk-coins)))
    #+END_SRC
20. [X] Exercise 2.20
    #+BEGIN_SRC scheme
      ;; The procedures +, *, and list take arbitrary numbers of arguments. One way to
      ;; define such procedures is to use define with dotted-tail notation. In a
      ;; procedure definition, a parameter list that has a dot before the last
      ;; parameter name indicates that, when the procedure is called, the initial
      ;; parameters (if any) will have as values the initial arguments, as usual, but
      ;; the final parameter's value will be a list of any remaining arguments. For
      ;; instance, given the definition

      ;; (define (f x y . z) <body>)

      ;; the procedure f can be called with two or more arguments. If we evaluate

      ;; (f 1 2 3 4 5 6)

      ;; then in the body of f, x will be 1, y will be 2, and z will be the list (3 4
      ;; 5 6). Given the definition

      ;; (define (g . w) <body>)

      ;; the procedure g can be called with zero or more arguments. If we evaluate

      ;; (g 1 2 3 4 5 6)

      ;; then in the body of g, w will be the list (1 2 3 4 5 6).

      ;; Use this notation to write a procedure same-parity that takes one or more
      ;; integers and returns a list of all the arguments that have the same even-odd
      ;; parity as the first argument. For example,

      (define keep
        (lambda (pred l)
          (cond
           ((null? l) l)
           ((pred (car l)) (cons (car l)
                                 (keep pred (cdr l))))
           (else (keep pred (cdr l))))))

      (define same-parity
        (lambda (a . xs)
          (if (even? a)
              (keep even? (cons a xs))
              (keep odd? (cons a xs)))))

      (list (equal? (same-parity 1 2 3 4 5 6 7)
                    (list 1 3 5 7))
            (equal? (same-parity 2 3 4 5 6 7)
                    (list 2 4 6)))
  #+END_SRC
21. [X] Exercise 2.21
    #+BEGIN_SRC scheme
      ;; The procedure square-list takes a list of numbers as argument and returns a
      ;; list of the squares of those numbers.

      ;; Here are two different definitions of square-list. Complete both of them by
      ;; filling in the missing expressions:

      (define square
        (lambda (n)
          (* n n)))

      (define (square-list items)
        (if (null? items)
            '()
            (cons (square (car items))
                  (square-list (cdr items)))))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))

      (define (square-list items)
        (map square items))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))
    #+END_SRC
22. [X] Exercise 2.22
    #+BEGIN_SRC scheme
      ;; Louis Reasoner tries to rewrite the first square-list procedure of exercise
      ;; 2.21 so that it evolves an iterative process:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons (square (car things))
                          answer))))
        (iter items nil))

      ;; Unfortunately, defining square-list this way produces the answer list in the
      ;; reverse order of the one desired. Why?

      ;; This one doesn't work because cons adds the answer to the head of the list.
      ;; This causes us to iterate backwards from the direction we should go.

      ;; Louis then tries to fix his bug by interchanging the arguments to cons:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons answer
                          (square (car things))))))
        (iter items nil))

      ;; This doesn't work either. Explain.

      ;; This doesn't work because we are consing onto an atom instead of a list.
    #+END_SRC
23. [X] Exercise 2.23
    #+BEGIN_SRC scheme
      ;; The procedure for-each is similar to map. It takes as arguments a procedure
      ;; and a list of elements. However, rather than forming a list of the results,
      ;; for-each just applies the procedure to each of the elements in turn, from
      ;; left to right. The values returned by applying the procedure to the elements
      ;; are not used at all -- for-each is used with procedures that perform an
      ;; action, such as printing. For example,

      (define for-each
        (lambda (proc data)
          (cond
           ((null? data) #t)
           (else (begin
                   (proc (car data))
                   (for-each proc (cdr data)))))))

      (for-each (lambda (x) (newline) (display x))
                (list 57 321 88))
      ;; 57
      ;; 321
      ;; 88

      ;; The value returned by the call to for-each (not illustrated above) can be
      ;; something arbitrary, such as true. Give an implementation of for-each.
    #+END_SRC

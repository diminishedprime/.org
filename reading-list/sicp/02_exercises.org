* TODO Chapter 2 Exercises [86%]
1. [ ] Exercise 2.1
2. [X] Exercise 2.2
    #+BEGIN_SRC scheme
      ;; Consider the problem of representing line segments in a plane. Each segment
      ;; is represented as a pair of points: a starting point and an ending point.
      ;; Define a constructor make-segment and selectors start-segment and end-segment
      ;; that define the representation of segments in terms of points. Furthermore, a
      ;; point can be represented as a pair of numbers: the x coordinate and the y
      ;; coordinate. Accordingly, specify a constructor make-point and selectors
      ;; x-point and y-point that define this representation. Finally, using your
      ;; selectors and constructors, define a procedure midpoint-segment that takes a
      ;; line segment as argument and returns its midpoint (the point whose
      ;; coordinates are the average of the coordinates of the endpoints). To try your
      ;; procedures, you’ll need a way to print points:

      (define make-point
        (lambda (x y)
          (list x y)))

      (define x-point
        (lambda (point)
          (car point)))

      (define y-point
        (lambda (point)
          (car (cdr point))))

      (define make-segment
        (lambda (point-1 point-2)
          (list point-1 point-2)))

      (define start-segment
        (lambda (segment)
          (car segment)))

      (define end-segment
        (lambda (segment)
          (car (cdr segment))))

      (define (print-point p)
        (newline)
        (display "(")
        (display (x-point p))
        (display ",")
        (display (y-point p))
        (display ")"))

      (define average
        (lambda (a b)
          (/ (+ a b) 2)))

      (define midpoint-segment
        (lambda (segment)
          (let ((point-1 (start-segment segment))
                (point-2 (end-segment segment)))
            (let ((x1 (x-point point-1))
                  (x2 (x-point point-2))
                  (y1 (y-point point-1))
                  (y2 (y-point point-2)))
              (make-point (average x1 x2)
                          (average y1 y2))))))


      (make-point 1 2)

      (x-point (make-point 1 2))

      (y-point (make-point 1 2))

      (make-segment (make-point 1 2)
                    (make-point 2 3))

      (start-segment (make-segment (make-point 1 2)
                                   (make-point 2 3)))

      (end-segment (make-segment (make-point 1 2)
                                 (make-point 2 3)))

      (midpoint-segment (make-segment (make-point 1 2)
                                      (make-point 2 3)))
     #+END_SRC
3. [X] Exercise 2.3
   #+BEGIN_SRC scheme
     ;; Implement a representation for rectangles in a plane. (Hint: You may want to
     ;; make use of Exercise 2.2.) In terms of your constructors and selectors,
     ;; create procedures that compute the perimeter and the area of a given
     ;; rectangle. Now implement a different representation for rectangles. Can you
     ;; design your system with suitable abstraction barriers, so that the same
     ;; perimeter and area procedures will work using either representation?

     (define make-rectangle
       (lambda (top-left bottom-right)
         (list top-left bottom-right)))

     (define top-left
       (lambda (rect)
         (car rect)))

     (define bottom-right
       (lambda (rect)
         (car (cdr rect))))

     (define perimeter-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (+ (* 2 height)
                  (* 2 width)))))))

     (define area-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (* height width))))))


     (make-rectangle (make-point 2 2)
                     (make-point 1 1))

     (top-left (make-rectangle (make-point 2 2)
                               (make-point 1 1)))

     (bottom-right (make-rectangle (make-point 2 2)
                                   (make-point 1 1)))


     (perimeter-rect (make-rectangle (make-point -3 2)
                                     (make-point 3 -8)))

     (area-rect (make-rectangle (make-point -3 2)
                                (make-point 3 -8)))
     #+END_SRC
4. [X] Exercise 2.4
   #+BEGIN_SRC scheme
     ;; Here is an alternative procedural representa- tion of pairs. For this
     ;; representation, verify that (car (cons x y)) yields x for any objects x and
     ;; y.

     (define (cons x y)
       (lambda (m) (m x y)))
              (define (car z)
                (z (lambda (p q) p)))

              (let ((a 1)
                    (b 2))
                (= (car (cons a b))
                   a)) ;; => #t

     ;; What is the corresponding definition of cdr? (Hint: To verify that this
     ;; works, make use of the substitution model of Section 1.1.5.)
     (define (cdr z)
       (z (lambda (p q) q)))

     (let ((a 1)
           (b 2))
       (= (cdr (cons a b))
          b))
     #+END_SRC
5. [X] Exercise 2.5
   #+BEGIN_SRC scheme
     ;; Show that we can represent pairs of non-negative integers using only numbers
     ;; and arithmetic operations if we represent the pair a and b as the integer
     ;; that is the product 2^a 3^b. Give the corresponding definitions of the
     ;; procedures cons, car, and cdr. I totally had to look this up online.
       (define (cons x y)
         (* (expt 2 x)
            (expt 3 y)))

       (define (log-reduce n base)
         (cond ((not (zero? (remainder n base))) 0)
               (else (+ (log-reduce (/ n base) base) 1))))

       (define (car z)
         (log-reduce z 2))

       (define (cdr z)
         (log-reduce z 3))

       (define test-pair (cons 11 7))
       (car test-pair) ;; => 11
       (cdr test-pair) ;; => 7
     #+END_SRC
6. [X] Exercise 2.6
   #+BEGIN_SRC scheme
     ;; In case representing pairs as procedures wasn’t mind-boggling enough,
     ;; consider that, in a language that can manipulate procedures, we can get by
     ;; without numbers (at least insofar as nonnegative integers are concerned) by
     ;; implementing 0 and the operation of adding 1 as
     (define zero
       (lambda (f)
         (lambda (x) x)))

     (define (add-1 n)
       (lambda (f)
         (lambda (x)
           (f ((n f) x)))))

     ;; This representation is known as Church numerals, after its inventor, Alonzo
     ;; Church, the logician who invented the λ-calculus.

     ;; Define one and two directly (not in terms of zero and add- 1). (Hint: Use
     ;; substitution to evaluate (add-1 zero)). Give a direct definition of the
     ;; addition procedure + (not in terms of repeated application of add-1).

     (define one
       (lambda (f)
         (lambda (x)
           (f x))))

     (define two
       (lambda (f)
         (lambda (x)
           (f (f x)))))

     ;; This is basic church encoding. If you put some effort in, you can see that
     ;; the composition of two church numbers are the same as addition. That's what
     ;; leads us to this result.

     (define (add a b)
       (lambda (f)
         (lambda (x)
           ((a f) ((b f) x)))))

       #+END_SRC
7. [X] Exercise 2.7
   #+BEGIN_SRC scheme
     ;; Setup
     (define (add-interval x y)
       (make-interval (+ (lower-bound x) (lower-bound y))
                      (+ (upper-bound x) (upper-bound y))))

     (define (mul-interval x y)
       (let ((p1 (* (lower-bound x) (lower-bound y)))
             (p2 (* (lower-bound x) (upper-bound y)))
             (p3 (* (upper-bound x) (lower-bound y)))
             (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))

     (define (div-interval x y)
       (mul-interval x
                     (make-interval (/ 1.0 (upper-bound y))
                                    (/ 1.0 (lower-bound y)))))

     ;; Alyssa's program is incomplete because she has not specified the
     ;; implementation of the interval abstraction. Here is a definition of the
     ;; interval constructor:

     (define (make-interval a b) (cons a b))

     ;; Define selectors upper-bound and lower-bound to complete the implementation.

     (define (make-interval a b) (cons a b))

     (define upper-bound
       (lambda (interval)
         (cdr interval)))

     (define lower-bound
       (lambda (interval)
         (car interval)))
   #+END_SRC
8. [X] Exercise 2.8
   #+BEGIN_SRC scheme
     ;; Using reasoning analogous to Alyssa's, describe how the difference of two
     ;; intervals may be computed. Define a corresponding subtraction procedure,
     ;; called sub-interval.
     (define sub-interval
       (lambda (x y)
         (let ((s1 (- (lower-bound x) (lower-bound y)))
               (s2 (- (lower-bound x) (upper-bound y)))
               (s3 (- (upper-bound x) (lower-bound y)))
               (s4 (- (upper-bound x) (upper-bound y))))
           (make-interval (min s1 s2 s3 s4)
                          (max s1 s2 s3 s4)))))


   #+END_SRC
9. [X] Exercise 2.9
   #+BEGIN_SRC scheme
     ;; The width of an interval is half of the difference between its upper and
     ;; lower bounds. The width is a measure of the uncertainty of the number
     ;; specified by the interval. For some arithmetic operations the width of the
     ;; result of combining two intervals is a function only of the widths of the
     ;; argument intervals, whereas for others the width of the combination is not a
     ;; function of the widths of the argument intervals. Show that the width of the
     ;; sum (or difference) of two intervals is a function only of the widths of the
     ;; intervals being added (or subtracted). Give examples to show that this is not
     ;; true for multiplication or division.

     (define interval-width
       (lambda (interval)
         (let ((difference (abs (- (lower-bound interval)
                                   (upper-bound interval)))))
           (/ difference 2))))

     (define same-width?
       (lambda (operation fn x y)
         (let ((width-x (interval-width x))
               (width-y (interval-width y))
               (width-res (interval-width (operation x y))))
           (= width-res (fn width-x width-y)))))

     (same-width? add-interval
                  +
                  (make-interval 3 4)
                  (make-interval 8 9))

     ;; add and subtract interval's width are both a function of +. Multiply and
     ;; divide return intervals are made by getting the minimum and the maximum of
     ;; the varients of the intervals. This means there is a loss of information
     ;; between the first and second intervals, and that information is necessary in
     ;; order to have a function that relates the two widths to the resulting width.
   #+END_SRC
10. [X] Exercise 2.10
    #+BEGIN_SRC scheme
      ;; Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
      ;; comments that it is not clear what it means to divide by an interval that
      ;; spans zero. Modify Alyssa's code to check for this condition and to signal an
      ;; error if it occurs.

      (define spans-zero?
        (lambda (x)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x)))
            (< (* x1 x2) 0))))

      (define (div-interval x y)
        (if (or (spans-zero? x)
                (spans-zero? y))
            'something-went-horribly-wrong
            (mul-interval x
                          (make-interval (/ 1.0 (upper-bound y))
                                         (/ 1.0 (lower-bound y))))))

      (list (div-interval (make-interval 3 4)
                          (make-interval -3 4))
            (div-interval (make-interval 3 4)
                          (make-interval -4 -3)))

    #+END_SRC
11. [X] Exercise 2.11
    #+BEGIN_SRC scheme
      ;; In passing, Ben also cryptically comments: ``By testing the signs of the
      ;; endpoints of the intervals, it is possible to break mul-interval into nine
      ;; cases, only one of which requires more than two multiplications.'' Rewrite
      ;; this procedure using Ben's suggestion.

      (define interval-makeup
        (lambda (interval)
          (let ((x1 (lower-bound interval))
                (x2 (upper-bound interval)))
            (cond
             ((and (< x1 0) (< x2 0)) -1)
             ((and (< x1 0) (< x2 0)) 0)
             (else 1)))))

      (define mul-interval
        (lambda (x y)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x))
                (y1 (lower-bound y))
                (y2 (lower-bound y))
                (sign-x (interval-makeup x))
                (sign-y (interval-makeup y)))
            (cond
             ((< sign-x 0) (cond
                            ;; - - - -
                            ((< sign-y 0) (make-interval (* x2 y2)
                                                         (* x1 y1)))
                            ;; - - - +
                            ((= sign-y 0) (make-interval (* x1 y2)
                                                         (* x1 y1)))
                            ;; - - + +
                            (else (make-interval (* x1 y2)
                                                 (* x2 y1)))))
             ((= sign 0) (cond
                          ;; - + - -
                          ((< sign-y 0) (make-interval (* x2 y1)
                                                       (* x1 y1)))
                          ;; - + - +
                          ((= sign-y 0) (make-interval (min (* x1 y2)
                                                            (* x2 y1))
                                                       (max (* x1 y1)
                                                            (* x2 y2))))
                          (else (make-interval (* x1 y2)
                                               (* x2 y2)))))
             (else (cond
                    ;; + + - -
                    ((< sign-y 0) (make-interval (* x2 y1)
                                                 (* x1 y2)))
                    ((= sign-y 0) (make-interval (* x2 y1)
                                                 (* x2 y2)))
                    (else (make-interval (* x1 y1)
                                         (* x2 y2)))))))))

      ;; After debugging her program, Alyssa shows it to a potential user, who
      ;; complains that her program solves the wrong problem. He wants a program that
      ;; can deal with numbers represented as a center value and an additive
      ;; tolerance; for example, he wants to work with intervals such as 3.5± 0.15
      ;; rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem
      ;; by supplying an alternate constructor and alternate selectors:

      (define (make-center-width c w)
        (make-interval (- c w) (+ c w)))
      (define (center i)
        (/ (+ (lower-bound i) (upper-bound i)) 2))
      (define (width i)
        (/ (- (upper-bound i) (lower-bound i)) 2))

      ;; Unfortunately, most of Alyssa's users are engineers. Real engineering
      ;; situations usually involve measurements with only a small uncertainty,
      ;; measured as the ratio of the width of the interval to the midpoint of the
      ;; interval. Engineers usually specify percentage tolerances on the parameters
      ;; of devices, as in the resistor specifications given earlier.
    #+END_SRC
12. [ ] Exercise 2.12
    #+BEGIN_SRC scheme
      ;; Define a constructor make-center-percent that takes a center and a percentage
      ;; tolerance and produces the desired interval. You must also define a selector
      ;; percent that produces the percentage tolerance for a given interval. The
      ;; center selector is the same as the one shown above.

      (define make-center-percent
        (lambda (center tolerance)
          (let ((diff (* center tolerance)))
            (let ((lower (- center tolerance))
                  (upper (+ center tolerance)))
              (make-interval lower upper)))))

      (define percent
        (lambda (interval)
          (let ((width (interval-width interval))
                (center (/ (+ (upper-bound interval)
                              (lower-bound interval)) 2))
                )
            (/ center width))))
    #+END_SRC
13. [ ]
14. [ ]
15. [ ]
16. [ ]
17. [X] Exercise 2.17
    #+BEGIN_SRC scheme
      ;; Define a procedure last-pair that returns the list that contains only the
      ;; last element of a given (nonempty) list:

      (define last-pair
        (lambda (l)
          (let ((len (length l)))
            (cond
             ((= len 1) l)
             (else (last-pair (cdr l)))))))

      (equal? (list 4) (last-pair (list 1 2 3 4)))
      (equal? (list 34) (last-pair (list 23 72 149 34)))
    #+END_SRC
18. [X] Exercise 2.18
    #+BEGIN_SRC scheme
      ;; Define a procedure reverse that takes a list as argument and returns a list
      ;; of the same elements in reverse order:

      (define (append list1 list2)
        (if (null? list1)
            list2
            (cons (car list1) (append (cdr list1) list2))))

      (define reverse
        (lambda (l)
          (cond
           ((null? l) l)
           (else (append (reverse (cdr l))
                         (list (car l)))))))

      (equal? (list 25 16 9 4 1)
              (reverse (list 1 4 9 16 25)))
    #+END_SRC
19. [X] Exercise 2.19
    #+BEGIN_SRC scheme
      ;; Consider the change-counting program of section 1.2.2. It would be nice to be
      ;; able to easily change the currency used by the program, so that we could
      ;; compute the number of ways to change a British pound, for example. As the
      ;; program is written, the knowledge of the currency is distributed partly into
      ;; the procedure first-denomination and partly into the procedure count-change
      ;; (which knows that there are five kinds of U.S. coins). It would be nicer to
      ;; be able to supply a list of coins to be used for making change.

      ;; We want to rewrite the procedure cc so that its second argument is a list of
      ;; the values of the coins to use rather than an integer specifying which coins
      ;; to use. We could then have lists that defined each kind of currency:

      (define us-coins (list 50 25 10 5 1))
      (define uk-coins (list 100 50 20 10 5 2 1 0.5))

      ;; We could then call cc as follows:

      ;; (cc 100 us-coins)

      ;; To do this will require changing the program cc somewhat. It will still have
      ;; the same form, but it will access its second argument differently, as
      ;; follows:

      (define first-denomination
        (lambda (coin-values)
          (car coin-values)))

      (define no-more?
        (lambda (coin-values)
          (null? coin-values)))

      (define except-first-denomination
        (lambda (coin-values)
          (cdr coin-values)))

      (define (cc amount coin-values)
        (cond ((= amount 0) 1)
              ((or (< amount 0) (no-more? coin-values)) 0)
              (else
               (+ (cc amount
                      (except-first-denomination coin-values))
                  (cc (- amount
                         (first-denomination coin-values))
                      coin-values)))))

      ;; Define the procedures first-denomination, except-first-denomination, and
      ;; no-more? in terms of primitive operations on list structures. Does the order
      ;; of the list coin-values affect the answer produced by cc? Why or why not?

      (cc 100 us-coins)

      ;; The answer is independent on the order of the coins. See this for an example

      (equal? (cc 25 uk-coins)
              (cc 25 (reverse uk-coins)))
    #+END_SRC
20. [X] Exercise 2.20
    #+BEGIN_SRC scheme
      ;; The procedures +, *, and list take arbitrary numbers of arguments. One way to
      ;; define such procedures is to use define with dotted-tail notation. In a
      ;; procedure definition, a parameter list that has a dot before the last
      ;; parameter name indicates that, when the procedure is called, the initial
      ;; parameters (if any) will have as values the initial arguments, as usual, but
      ;; the final parameter's value will be a list of any remaining arguments. For
      ;; instance, given the definition

      ;; (define (f x y . z) <body>)

      ;; the procedure f can be called with two or more arguments. If we evaluate

      ;; (f 1 2 3 4 5 6)

      ;; then in the body of f, x will be 1, y will be 2, and z will be the list (3 4
      ;; 5 6). Given the definition

      ;; (define (g . w) <body>)

      ;; the procedure g can be called with zero or more arguments. If we evaluate

      ;; (g 1 2 3 4 5 6)

      ;; then in the body of g, w will be the list (1 2 3 4 5 6).

      ;; Use this notation to write a procedure same-parity that takes one or more
      ;; integers and returns a list of all the arguments that have the same even-odd
      ;; parity as the first argument. For example,

      (define keep
        (lambda (pred l)
          (cond
           ((null? l) l)
           ((pred (car l)) (cons (car l)
                                 (keep pred (cdr l))))
           (else (keep pred (cdr l))))))

      (define same-parity
        (lambda (a . xs)
          (if (even? a)
              (keep even? (cons a xs))
              (keep odd? (cons a xs)))))

      (list (equal? (same-parity 1 2 3 4 5 6 7)
                    (list 1 3 5 7))
            (equal? (same-parity 2 3 4 5 6 7)
                    (list 2 4 6)))
  #+END_SRC
21. [X] Exercise 2.21
    #+BEGIN_SRC scheme
      ;; The procedure square-list takes a list of numbers as argument and returns a
      ;; list of the squares of those numbers.

      ;; Here are two different definitions of square-list. Complete both of them by
      ;; filling in the missing expressions:

      (define square
        (lambda (n)
          (* n n)))

      (define (square-list items)
        (if (null? items)
            '()
            (cons (square (car items))
                  (square-list (cdr items)))))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))

      (define (square-list items)
        (map square items))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))
    #+END_SRC
22. [X] Exercise 2.22
    #+BEGIN_SRC scheme
      ;; Louis Reasoner tries to rewrite the first square-list procedure of exercise
      ;; 2.21 so that it evolves an iterative process:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons (square (car things))
                          answer))))
        (iter items nil))

      ;; Unfortunately, defining square-list this way produces the answer list in the
      ;; reverse order of the one desired. Why?

      ;; This one doesn't work because cons adds the answer to the head of the list.
      ;; This causes us to iterate backwards from the direction we should go.

      ;; Louis then tries to fix his bug by interchanging the arguments to cons:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons answer
                          (square (car things))))))
        (iter items nil))

      ;; This doesn't work either. Explain.

      ;; This doesn't work because we are consing onto an atom instead of a list.
    #+END_SRC
23. [X] Exercise 2.23
    #+BEGIN_SRC scheme
      ;; The procedure for-each is similar to map. It takes as arguments a procedure
      ;; and a list of elements. However, rather than forming a list of the results,
      ;; for-each just applies the procedure to each of the elements in turn, from
      ;; left to right. The values returned by applying the procedure to the elements
      ;; are not used at all -- for-each is used with procedures that perform an
      ;; action, such as printing. For example,

      (define for-each
        (lambda (proc data)
          (cond
           ((null? data) #t)
           (else (begin
                   (proc (car data))
                   (for-each proc (cdr data)))))))

      (for-each (lambda (x) (newline) (display x))
                (list 57 321 88))
      ;; 57
      ;; 321
      ;; 88

      ;; The value returned by the call to for-each (not illustrated above) can be
      ;; something arbitrary, such as true. Give an implementation of for-each.
    #+END_SRC
24. [X] Exercise 2.24
    #+BEGIN_SRC scheme
      ;; Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the
      ;; result printed by the interpreter, the corresponding box-and-pointer
      ;; structure, and the interpretation of this as a tree (as in figure 2.6).

      ;; I can't really draw since this is only text, but I'll do my best

      '(1 (2 (3 4)))

      [*] [*] ---> [*] [/]
       |            |
       v            v
      [1]          [*] [*] ---> [*] [/]
                    |            |
                    v            v
                   [2]          [*] [*] ---> [*] [/]
                                 |            |
                                 v            v
                                [3]          [4]

                        (list 1 (list 2 (list 3 4)))
                            /          \
                           1       (list 2 (list 3 4))
                                     /         \
                                    2        (list 3 4)
                                                /   \
                                               3     4
    #+END_SRC
25. [X] Exercise 2.25
    #+BEGIN_SRC scheme
      ;; Give combinations of cars and cdrs that will pick 7 from each of the
      ;; following lists:
      (car
       (cdr
        (car
         (cdr
          (cdr
           '(1 3 (5 7) 9)
           ) ;; (3 (5 7) 9)
          ) ;; ((5 7) 9)
         ) ;; (5 7)
        ) ;; (7)
       ) ;; 7

      (car
       (car
        '((7))
        ) ;; (7)
       ) ;; 7

      (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7))))))))))))))))))
    #+END_SRC
26. [X] Exercise 2.26
    #+BEGIN_SRC scheme
      ;; Suppose we define x and y to be two lists:

      (define x (list 1 2 3))
      (define y (list 4 5 6))

      ;; What result is printed by the interpreter in response to evaluating each of
      ;; the following expressions:

      (append x y) ;; => (1 2 3 4 5 6)

      (cons x y) ;; => ((1 2 3) 4 5 6)

      (list x y) ;; => ((1 2 3) (4 5 6))
    #+END_SRC
27. [X] Exercise 2.27
    #+BEGIN_SRC scheme
      ;; Modify your reverse procedure of exercise 2.18 to produce a deep-reverse
      ;; procedure that takes a list as argument and returns as its value the list
      ;; with its elements reversed and with all sublists deep-reversed as well. For
      ;; example,

      (define reverse
        (lambda (l)
          (cond
           ((null? l) l)
           (else (append (reverse (cdr l))
                         (list (car l)))))))

      (define (deep-reverse items)
        (define (iter items acc)
          (cond
           ((null? items) acc)
           ((list? (car items)) (iter (cdr items)
                                      (append (list (deep-reverse (car items))) acc)))
           (else (iter (cdr items)
                       (append (list (car items)) acc)))))
        (iter items '()))

      (define x (list (list 1 2) (list 3 4)))

      x ;; => ((1 2) (3 4))

      (reverse x) ;; => ((3 4) (1 2))

      (deep-reverse x) ;; => ((4 3) (2 1))

    #+END_SRC
28. [X] Exercise 2.28
    #+BEGIN_SRC scheme
      ;; Write a procedure fringe that takes as argument a tree (represented as a
      ;; list) and returns a list whose elements are all the leaves of the tree
      ;; arranged in left-to-right order. For example,

      (define fringe
        (lambda (tree)
          (cond
           ((null? tree) tree)

           ((list? (car tree)) (append (fringe (car tree))
                                       (fringe (cdr tree))))

           (else (cons (car tree)
                       (fringe (cdr tree)))))))

      (define x (list (list 1 2) (list 3 4)))

      (fringe x) ;; => (1 2 3 4)

      (fringe (list x x)) ;; => (1 2 3 4 1 2 3 4)
    #+END_SRC
29. [X] Exercise 2.29
    #+BEGIN_SRC scheme
      ;; A binary mobile consists of two branches, a left branch and a right branch.
      ;; Each branch is a rod of a certain length, from which hangs either a weight or
      ;; another binary mobile. We can represent a binary mobile using compound data
      ;; by constructing it from two branches (for example, using list):

      (define (make-mobile left right)
        (list left right))

      ;; A branch is constructed from a length (which must be a number) together with
      ;; a structure, which may be either a number (representing a simple weight) or
      ;; another mobile:

      (define (make-branch length structure)
        (list length structure))

      ;; a. Write the corresponding selectors left-branch and right-branch, which
      ;; return the branches of a mobile, and branch-length and branch-structure,
      ;; which return the components of a branch.

      (define first
        (lambda (l)
          (car l)))

      (define second
        (lambda (l)
          (first (cdr l))))

      (define left-branch
        (lambda (mobile)
          (first mobile)))

      (define right-branch
        (lambda (mobile)
          (second mobile)))

      (define branch-length
        (lambda (branch)
          (first branch)))

      (define branch-structure
        (lambda (branch)
          (second branch)))

      ;; b. Using your selectors, define a procedure total-weight that returns the
      ;; total weight of a mobile.

      (define total-weight
        (lambda (structure)
          (cond
           ((number? structure) structure)
           (else (let ((l-branch (left-branch structure))
                       (r-branch (right-branch structure)))
                   (let ((r-struct (branch-structure r-branch))
                         (l-struct (branch-structure l-branch)))
                     (+ (total-weight l-struct)
                        (total-weight r-struct))))))))

      ;; c. A mobile is said to be balanced if the torque applied by its top-left
      ;; branch is equal to that applied by its top-right branch (that is, if the
      ;; length of the left rod multiplied by the weight hanging from that rod is
      ;; equal to the corresponding product for the right side) and if each of the
      ;; submobiles hanging off its branches is balanced. Design a predicate that
      ;; tests whether a binary mobile is balanced.

      (define balanced-simple
        (make-mobile
         (make-branch 2 3)
         (make-branch 3 2)))

      (define balanced-complex
        (make-mobile
         (make-branch 2 (make-mobile
                         (make-branch 6 2)
                         (make-branch 3 4)))
         (make-branch 2 6)))

      (define unbalanced-simple
        (make-mobile
         (make-branch 2 3)
         (make-branch 3 200)))

      (define unbalanced-complex
        (make-mobile
         (make-branch 2 (make-mobile
                         (make-branch 6 2)
                         (make-branch 3 4)))
         (make-branch 2 60)))

      (define structure-mobile?
        (lambda (structure)
          (not (number? structure))))

      (define torque
        (lambda (branch)
          (* (total-weight (branch-structure branch))
             (branch-length branch))))

      (define mobile-balanced?
        (lambda (mobile)
          (let ((l-branch (left-branch mobile))
                (r-branch (right-branch mobile)))
            (let ((r-struct (branch-structure r-branch))
                  (l-struct (branch-structure l-branch)))
              (and (if (structure-mobile? r-struct) (mobile-balanced? r-struct) #t)
                   (if (structure-mobile? l-struct) (mobile-balanced? l-struct) #t)
                   (eq? (torque l-branch)
                        (torque r-branch)))))))

      ;; d. Suppose we change the representation of mobiles so that the constructors
      ;; are

      (define (make-mobile left right)
        (cons left right))
      (define (make-branch length structure)
        (cons length structure))

      ;; How much do you need to change your programs to convert to the new
      ;; representation?

      ;; All I need to change is the selectors.

      (define left-branch
        (lambda (mobile)
          (car mobile)))

      (define right-branch
        (lambda (mobile)
          (cdr mobile)))

      (define branch-length
        (lambda (branch)
          (car branch)))

      (define branch-structure
        (lambda (branch)
          (cdr branch)))


      ;; Mapping over trees

      ;; Just as map is a powerful abstraction for dealing with sequences, map
      ;; together with recursion is a powerful abstraction for dealing with trees. For
      ;; instance, the scale-tree procedure, analogous to scale-list of section 2.2.1,
      ;; takes as arguments a numeric factor and a tree whose leaves are numbers. It
      ;; returns a tree of the same shape, where each number is multiplied by the
      ;; factor. The recursive plan for scale-tree is similar to the one for
      ;; count-leaves:

      (define (scale-tree tree factor)
        (cond ((null? tree) nil)
              ((not (pair? tree)) (* tree factor))
              (else (cons (scale-tree (car tree) factor)
                          (scale-tree (cdr tree) factor)))))

      (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
                  10) ;; => (10 (20 (30 40) 50) (60 70))

      ;; Another way to implement scale-tree is to regard the tree as a sequence of
      ;; sub-trees and use map. We map over the sequence, scaling each sub-tree in
      ;; turn, and return the list of results. In the base case, where the tree is a
      ;; leaf, we simply multiply by the factor:

      (define (scale-tree tree factor)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (scale-tree sub-tree factor)
                   (* sub-tree factor)))
             tree))

      ;; Many tree operations can be implemented by similar combinations of sequence
      ;; operations and recursion.
    #+END_SRC
30. [X] Exercise 2.30
    #+BEGIN_SRC scheme
      ;; Define a procedure square-tree analogous to the square-list procedure of
      ;; exercise 2.21. That is, square-list should behave as follows:

      ;; Define square-tree both directly (i.e., without using any higher-order
      ;; procedures) and also by using map and recursion.

      (define square
        (lambda (num)
          (* num num)))

      (define (square-tree-1 tree)
        (cond ((null? tree) '())
              ((not (pair? tree)) (square tree))
              (else (cons (square-tree-1 (car tree))
                          (square-tree-1 (cdr tree))))))

      (square-tree-1
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7))) ;; => (1 (4 (9 16) 25) (36 49))

      (define (square-tree-2 tree)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (square-tree-2 sub-tree)
                   (square sub-tree)))
             tree))

      (square-tree-2
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7))) ;; => (1 (4 (9 16) 25) (36 49))


    #+END_SRC
31. [X] Exercise 2.31
    #+BEGIN_SRC scheme
      ;; Abstract your answer to exercise 2.30 to produce a procedure tree-map with
      ;; the property that square-tree could be defined as

      (define (tree-map fn tree)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (tree-map fn sub-tree)
                   (fn sub-tree)))
             tree))

      (define square
        (lambda (n)
          (* n n)))

      (define (square-tree tree) (tree-map square tree))
    #+END_SRC
32. [X] Exercise 2.32
    #+BEGIN_SRC scheme
      ;; We can represent a set as a list of distinct elements, and we can represent
      ;; the set of all subsets of the set as a list of lists. For example, if the set
      ;; is (1 2 3), then the set of all subsets is (() (3) (2) (2 3) (1) (1 3) (1 2)
      ;; (1 2 3)). Complete the following definition of a procedure that generates the
      ;; set of subsets of a set and give a clear explanation of why it works:

      (define (subsets s)
        (if (null? s)
            (list '())
            (let ((rest (subsets (cdr s))))
              (append rest (map
                            (lambda (x)
                              (append (list (car s)) x))
                            rest)))))

      ;; 1. Let's think about what rest will be the first time it's called with '(1 2
      ;; 3). rest will be the subsets of '(2 3). Now lets see what that will be.

      ;; 2. Let's think about what rest will be ... '(2 3). rest will be the subsets
      ;; of '(3). Now let's see what that will be.

      ;; 3. Let's think about what rest will be ... '(3). rest will be the subsets of
      ;; '(). We know the answer to this. It's '(()).

      ;; 4. Now we can go back to step 2 and continue with the second half. With rest
      ;; being '(()), we will fill in the code as follows.
      (append '(()) (map
                     (lambda (x)
                       (append (list (car '(3))) x))
                     '(())))
      ;; Since we're only mapping over one piece of data, let's go ahead and replace
      ;; into this one.
      (lambda ( '(3) )
        (append (list (car '(3))) '()))

      (append (list (car '(3))) '())

      (append (list 3) '())
      (append '(3) '())
      ;; And now that map is done, we append rest with '(3)
      (append '(()) '(3)) ;; => '(() (3))
      ;; This gives us '(() (3)) which are the subsets of '(3).

      ;; If you follow this same line of logic, you can see why mapping over (() (3))
      ;; and then appending that will give us the subsets of '(2 3). Following this
      ;; logic further leads up to getting the subsets of '(1 2 3)

      (subsets '(1 2 3))
    #+END_SRC
33. [X] Exercise 2.33
    #+BEGIN_SRC scheme
      ;; Fill in the missing expressions to complete the following definitions of some
      ;; basic list-manipulation operations as accumulations:

      (define (filter predicate sequence)
        (cond ((null? sequence) '())
              ((predicate (car sequence))
               (cons (car sequence)
                     (filter predicate (cdr sequence))))
              (else (filter predicate (cdr sequence)))))

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (map p sequence)
        (accumulate (lambda (x y)
                      (cons (p x) y)) '() sequence))

      (define (append seq1 seq2)
        (accumulate cons seq2 seq1))

      (define (length sequence)
        (accumulate (lambda (x y)
                      (+ y 1)) 0 sequence))
    #+END_SRC
34. [X] Exercise 2.34
    #+BEGIN_SRC scheme
      ;; Evaluating a polynomial in x at a given value of x can be formulated as an
      ;; accumulation. In other words, we start with an, multiply by x, add an-1,
      ;; multiply by x, and so on, until we reach a0.16 Fill in the following template
      ;; to produce a procedure that evaluates a polynomial using Horner's rule.
      ;; Assume that the coefficients of the polynomial are arranged in a sequence,
      ;; from a0 through an.
      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (horner-eval x coefficient-sequence)
        (accumulate (lambda (this-coeff higher-terms)
                      (+ this-coeff
                         (* higher-terms x)))
                    0
                    coefficient-sequence))

      ;; For example, to compute 1 + 3x + 5x3 + x5 at x = 2 you would evaluate

      (horner-eval 2 (list 1 3 0 5 0 1))
    #+END_SRC
35. [X] Exercise 2.35
    #+BEGIN_SRC scheme
      ;; Redefine count-leaves from section 2.2.2 as an accumulation:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (count-leaves t)
        (accumulate + 0 (map (lambda (tree)
                               (if (pair? tree)
                                   (count-leaves tree)
                                   1)) t)))

      (define x (cons (list 1 2) (list 3 4)))
      (count-leaves (list x x)) ;; => 8
    #+END_SRC
36. [X] Exercise 2.36
    #+BEGIN_SRC scheme
      ;; The procedure accumulate-n is similar to accumulate except that it takes as
      ;; its third argument a sequence of sequences, which are all assumed to have the
      ;; same number of elements. It applies the designated accumulation procedure to
      ;; combine all the first elements of the sequences, all the second elements of
      ;; the sequences, and so on, and returns a sequence of the results. For
      ;; instance, if s is a sequence containing four sequences, ((1 2 3) (4 5 6) (7 8
      ;; 9) (10 11 12)), then the value of (accumulate-n + 0 s) should be the sequence
      ;; (22 26 30). Fill in the missing expressions in the following definition of
      ;; accumulate-n:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (accumulate-n op init seqs)
        (if (null? (car seqs))
            '()
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))

      (accumulate-n + 0 '((1  2  3)
                          (4  5  6)
                          (7  8  9)
                          (10 11 12)))
    #+END_SRC
37. [X] Exercise 2.37
    #+BEGIN_SRC scheme
      ;; Suppose we represent vectors v = (vi) as sequences of numbers, and matrices m
      ;; = (mij) as sequences of vectors (the rows of the matrix). For example, the
      ;; matrix

      ;; 1 2 3 4
      ;; 4 5 6 6
      ;; 6 7 8 9

      ;; is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)). With this
      ;; representation, we can use sequence operations to concisely express the basic
      ;; matrix and vector operations. These operations (which are described in any
      ;; book on matrix algebra) are the following:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (accumulate-n op init seqs)
        (if (null? (car seqs))
            '()
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))

      ;; We can define the dot product as
      (define (dot-product v w)
        (accumulate + 0 (map * v w)))

      (print (dot-product '(1 2 3)
                          '(1 2 3)))

      ;; Fill in the missing expressions in the following procedures for computing the
      ;; other matrix operations. (The procedure accumulate-n is defined in exercise
      ;; 2.36.)

      (define (matrix-*-vector m v)
        (map (lambda (row)
               (dot-product row v)) m))

      (print (matrix-*-vector '((1 2 3)
                                (4 5 6)
                                (7 8 9))
                              '(1 2 3)))

      (define (transpose mat)
        (accumulate-n cons '() mat))

      (print (transpose '((1 2 3)
                          (4 5 6)
                          (7 8 9))))

      (define (matrix-*-matrix m n)
        (let ((cols (transpose n)))
          (map (lambda (x)
                 (map (lambda (y)
                        (dot-product x y))
                      cols))
               m)))

      (print (matrix-*-matrix '((1 2 3)
                                (2 3 4))
                              '((2 3 4)
                                (5 7 9)
                                (4 9 1))))
    #+END_SRC
38. [X] Exercise 2.38
    #+BEGIN_SRC scheme
      ;; The accumulate procedure is also known as fold-right, because it combines
      ;; the first element of the sequence with the result of combining all the
      ;; elements to the right. There is also a fold-left, which is similar to
      ;; fold-right, except that it combines elements working in the opposite
      ;; direction:

      (define (fold-left op initial sequence)
        (define (iter result rest)
          (if (null? rest)
              result
              (iter (op result (car rest))
                    (cdr rest))))
        (iter initial sequence))

      ;; What are the values of

      (print (fold-right / 1 (list 1 2 3))) ;; => 1.5
      (print (fold-left / 1 (list 1 2 3))) ;; => .166...
      (print (fold-right list '() (list 1 2 3))) ;; => (1 (2 (3 ())))
      (print (fold-left list '() (list 1 2 3))) ;; => (((() 1) 2) 3)

      ;; Give a property that op should satisfy to guarantee that fold-right and
      ;; fold-left will produce the same values for any sequence.

      ;; the associative property
    #+END_SRC
39. [X] Exercise 2.39.
    #+BEGIN_SRC scheme
      ;; Complete the following definitions of reverse (exercise 2.18) in terms of
      ;; fold-right and fold-left from exercise 2.38:

      (define (reverse sequence)
        (fold-right (lambda (x y)
                      (append y (list x)))
                    '() sequence))

      (print (reverse '(1 2 3)))

      (define (reverse sequence)
        (fold-left (lambda (x y)
                     (append (list y) x)
                     ) '() sequence))

      (print (reverse '(1 2 3)))

      ;; Nested Mappings

      ;; We can extend the sequence paradigm to include many computations that are
      ;; commonly expressed using nested loops.18 Consider this problem: Given a
      ;; positive integer n, find all ordered pairs of distinct positive integers i
      ;; and j, where 1< j< i< n, such that i + j is prime. For example, if n is 6,
      ;; then the pairs are the following:

      ;; |-----+---+---+---+---+---+---+----|
      ;; | i   | 2 | 3 | 4 | 4 | 5 | 6 |  6 |
      ;; | j   | 1 | 2 | 1 | 3 | 2 | 1 |  5 |
      ;; |-----+---+---+---+---+---+---+----|
      ;; | i+j | 3 | 5 | 5 | 7 | 7 | 7 | 11 |
      ;; |-----+---+---+---+---+---+---+----|

      ;; A natural way to organize this computation is to generate the sequence of all
      ;; ordered pairs of positive integers less than or equal to n, filter to select
      ;; those pairs whose sum is prime, and then, for each pair (i, j) that passes
      ;; through the filter, produce the triple (i,j,i + j).

      ;; Here is a way to generate the sequence of pairs: For each integer i< n,
      ;; enumerate the integers j<i, and for each such i and j generate the pair
      ;; (i,j). In terms of sequence operations, we map along the sequence
      ;; (enumerate-interval 1 n). For each i in this sequence, we map along the
      ;; sequence (enumerate-interval 1 (- i 1)). For each j in this latter sequence,
      ;; we generate the pair (list i j). This gives us a sequence of pairs for each
      ;; i. Combining all the sequences for all the i (by accumulating with append)
      ;; produces the required sequence of pairs:19

      (accumulate append
                  '()
                  (map (lambda (i)
                         (map (lambda (j) (list i j))
                              (enumerate-interval 1 (- i 1))))
                       (enumerate-interval 1 n)))

      ;; The combination of mapping and accumulating with append is so common in this
      ;; sort of program that we will isolate it as a separate procedure:

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      ;; Now filter this sequence of pairs to find those whose sum is prime. The
      ;; filter predicate is called for each element of the sequence; its argument is
      ;; a pair and it must extract the integers from the pair. Thus, the predicate to
      ;; apply to each element in the sequence is

      (define (prime-sum? pair)
        (prime? (+ (car pair) (cadr pair))))

      ;; Finally, generate the sequence of results by mapping over the filtered pairs
      ;; using the following procedure, which constructs a triple consisting of the
      ;; two elements of the pair along with their sum:

      (define (make-pair-sum pair)
        (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

      ;; Combining all these steps yields the complete procedure:

      (define (prime-sum-pairs n)
        (map make-pair-sum
             (filter prime-sum?
                     (flatmap
                      (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))))

      ;; Nested mappings are also useful for sequences other than those that enumerate
      ;; intervals. Suppose we wish to generate all the permutations of a set S; that
      ;; is, all the ways of ordering the items in the set. For instance, the
      ;; permutations of {1,2,3} are {1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2},
      ;; and { 3,2,1}. Here is a plan for generating the permutations of S: For each
      ;; item x in S, recursively generate the sequence of permutations of S - x,20
      ;; and adjoin x to the front of each one. This yields, for each x in S, the
      ;; sequence of permutations of S that begin with x. Combining these sequences
      ;; for all x gives all the permutations of S:21

      (define (permutations s)
        (if (null? s)                    ; empty set?
            (list '())                   ; sequence containing empty set
            (flatmap (lambda (x)
                       (map (lambda (p) (cons x p))
                            (permutations (remove x s))))
                     s)))

      ;; Notice how this strategy reduces the problem of generating permutations of S
      ;; to the problem of generating the permutations of sets with fewer elements
      ;; than S. In the terminal case, we work our way down to the empty list, which
      ;; represents a set of no elements. For this, we generate (list '()), which is a
      ;; sequence with one item, namely the set with no elements. The remove procedure
      ;; used in permutations returns all the items in a given sequence except for a
      ;; given item. This can be expressed as a simple filter:

      (define (remove item sequence)
        (filter (lambda (x) (not (= x item)))
                sequence))
    #+END_SRC
40. [X] Exercise 2.40
    #+BEGIN_SRC scheme
      ;; Define a procedure unique-pairs that, given an integer n, generates the
      ;; sequence of pairs (i,j) with 1< j< i< n. Use unique-pairs to simplify the
      ;; definition of prime-sum-pairs given above.

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      (define enumerate-interval
        (lambda (from to)
          (cond
           ((>= from to) '())
           (else (cons from (enumerate-interval (+ from 1) to))))))

      (define unique-pairs
        (lambda (n)
          (flatmap (lambda (i)
                     (map (lambda (j)
                            (list i j))
                          (enumerate-interval 1 i)))
                   (enumerate-interval 1 n))))
    #+END_SRC
41. [X] Exercise 2.41
    #+BEGIN_SRC scheme
      ;; Write a procedure to find all ordered triples of distinct positive integers
      ;; i, j, and k less than or equal to a given integer n that sum to a given
      ;; integer s.

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      (define enumerate-interval
        (lambda (from to)
          (cond
           ((>= from to) '())
           (else (cons from (enumerate-interval (+ from 1) to))))))


      (define first car)
      (define second cadr)
      (define third caddr)

      (define valid-triplets
        (lambda (n)
          (flatmap (lambda (i)
                     (flatmap (lambda (j)
                                (map (lambda (k)
                                       (list i j k))
                                     (enumerate-interval 1 n)))
                              (enumerate-interval 1 n)))
                   (enumerate-interval 1 n))))

      (define sum-to-s?
        (lambda (s triplet)
          (lambda (triplet)
            (eq? s (+ (first triplet)
                      (second triplet)
                      (third triplet))))))

      (define distinct-triplet?
        (lambda (triplet)
          (let ((a (first triplet))
                (b (second triplet))
                (c (third triplet)))
            (and (not (eq? a b))
                 (not (eq? b c))
                 (not (eq? a c))))))

      (define problem-proc
        (lambda (s n)
          (filter (sum-to-s? s)
                  (filter distinct-triplet? (valid-triplets n)))))

      (problem-proc 6 10)
    #+END_SRC
42. [X] Exercise 2.42.
    [[./eight-queeens.gif]]
    #+BEGIN_SRC scheme
      ;; The ``eight-queens puzzle'' asks how to place eight queens on a chessboard so
      ;; that no queen is in check from any other (i.e., no two queens are in the same
      ;; row, column, or diagonal). One possible solution is shown in figure 2.8. One
      ;; way to solve the puzzle is to work across the board, placing a queen in each
      ;; column. Once we have placed k - 1 queens, we must place the kth queen in a
      ;; position where it does not check any of the queens already on the board. We
      ;; can formulate this approach recursively: Assume that we have already
      ;; generated the sequence of all possible ways to place k - 1 queens in the
      ;; first k - 1 columns of the board. For each of these ways, generate an
      ;; extended set of positions by placing a queen in each row of the kth column.
      ;; Now filter these, keeping only the positions for which the queen in the kth
      ;; column is safe with respect to the other queens. This produces the sequence
      ;; of all ways to place k queens in the first k columns. By continuing this
      ;; process, we will produce not only one solution, but all solutions to the
      ;; puzzle.

      ;; We implement this solution as a procedure queens, which returns a sequence of
      ;; all solutions to the problem of placing n queens on an n× n chessboard.
      ;; Queens has an internal procedure queen-cols that returns the sequence of all
      ;; ways to place queens in the first k columns of the board.

      (define flatmap
        (lambda (proc seq)
          (fold-left append '()
                     (map proc seq))))

      (define (enumerate-interval low high)
        (if (> low high)
            '()
            (cons low (enumerate-interval (+ low 1) high))))

      (define (make-position row col)
        (cons row col))

      (define (position-row position)
        (car position))

      (define (position-col position)
        (cdr position))

      (define empty-board '())

      (define (adjoin-position row col positions)
        (append positions (list (make-position row col))))


      (define (safe? col positions)
        (let ((kth-queen (list-ref positions (- col 1)))
              (other-queens (filter (lambda (q)
                                      (not (= col (position-col q))))
                                    positions)))
          (define (attacks? q1 q2)
            (or (= (position-row q1) (position-row q2))
                (= (abs (- (position-row q1) (position-row q2)))
                   (abs (- (position-col q1) (position-col q2))))))

          (define (iter q board)
            (or (null? board)
                (and (not (attacks? q (car board)))
                     (iter q (cdr board)))))
          (iter kth-queen other-queens)))

      (define (queens board-size)
        (define (queen-cols k)
          (if (= k 0)
              (list empty-board)
              (filter
               (lambda (positions) (safe? k positions))
               (flatmap
                (lambda (rest-of-queens)
                  (map (lambda (new-row)
                         (adjoin-position new-row k rest-of-queens))
                       (enumerate-interval 1 board-size)))
                (queen-cols (- k 1))))))
        (queen-cols board-size))

      ;; In this procedure rest-of-queens is a way to place k - 1 queens in the first
      ;; k - 1 columns, and new-row is a proposed row in which to place the queen for
      ;; the kth column. Complete the program by implementing the representation for
      ;; sets of board positions, including the procedure adjoin-position, which
      ;; adjoins a new row-column position to a set of positions, and empty-board,
      ;; which represents an empty set of positions. You must also write the procedure
      ;; safe?, which determines for a set of positions, whether the queen in the kth
      ;; column is safe with respect to the others. (Note that we need only check
      ;; whether the new queen is safe -- the other queens are already guaranteed safe
      ;; with respect to each other.)
    #+END_SRC
43. [X] Exercise 2.43
    #+BEGIN_SRC scheme
      ;; Louis Reasoner is having a terrible time doing exercise 2.42. His queens
      ;; procedure seems to work, but it runs extremely slowly. (Louis never does
      ;; manage to wait long enough for it to solve even the 6× 6 case.) When Louis
      ;; asks Eva Lu Ator for help, she points out that he has interchanged the order
      ;; of the nested mappings in the flatmap, writing it as

      (flatmap
       (lambda (new-row)
         (map (lambda (rest-of-queens)
                (adjoin-position new-row k rest-of-queens))
              (queen-cols (- k 1))))
       (enumerate-interval 1 board-size))

      ;; Explain why this interchange makes the program run slowly. Estimate how long
      ;; it will take Louis's program to solve the eight-queens puzzle, assuming that
      ;; the program in exercise 2.42 solves the puzzle in time T.

      ;; The problem is that this one grows exponentially because by switching the
      ;; order we changed this to be a tree recursive process instead of a linear
      ;; recursive process like before.
    #+END_SRC
44. [X] Exercise 2.44
    #+BEGIN_SRC scheme
      ;; Define the procedure up-split used by corner-split. It is similar to
      ;; right-split, except that it switches the roles of below and beside.

      (define up-split
        (lambda painter n
                (if (= n 0)
                    painter
                    (let ((smaller (up-split painter (- n 1))))
                      (below painter (beside smaller smaller))))))
    #+END_SRC
45. [X] Exercise 2.45
    #+BEGIN_SRC scheme
      ;; Right-split and up-split can be expressed as instances of a general splitting
      ;; operation. Define a procedure split with the property that evaluating

      (define split
        (lambda (original-placer split-placer)
          (lambda (painter n)
            (cond
             ((= n 0) painter)
             (else (let ((smaller ((split original-placer
                                          split-placer)
                                   painter (- n 1))))
                     (original-placer painter (split-painter smaller smaller))))))))

      (define right-split (split beside below))
      (define up-split (split below beside))
    #+END_SRC

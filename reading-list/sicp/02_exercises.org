+ [[../index.org][Reading Index]]
+ [[../mit_sicp.org][SICP]]

* TODO Chapter 2 Exercises [92%]
1. [X] Exercise 2.1
   #+BEGIN_SRC scheme
     ;; Define a better version of make-rat that handles both positive and negative
     ;; arguments. Make-rat should normalize the sign so that if the rational number
     ;; is positive, both the numerator and denominator are positive, and if the
     ;; rational number is negative, only the numerator is negative.

     (define (gcd a b)
       (if (= b 0)
           a
           (gcd b (mod a b))))

     (define (make-rat n d)
       (let ((g ((if (< d 0) - +)
                 (abs (gcd n d)))))
         (cons (/ n g)
               (/ d g))))

     (list (make-rat 3 4)
           (make-rat -3 -4)
           (make-rat -3 4)
           (make-rat 3 -4))
   #+END_SRC
2. [X] Exercise 2.2
    #+BEGIN_SRC scheme
      ;; Consider the problem of representing line segments in a plane. Each segment
      ;; is represented as a pair of points: a starting point and an ending point.
      ;; Define a constructor make-segment and selectors start-segment and end-segment
      ;; that define the representation of segments in terms of points. Furthermore, a
      ;; point can be represented as a pair of numbers: the x coordinate and the y
      ;; coordinate. Accordingly, specify a constructor make-point and selectors
      ;; x-point and y-point that define this representation. Finally, using your
      ;; selectors and constructors, define a procedure midpoint-segment that takes a
      ;; line segment as argument and returns its midpoint (the point whose
      ;; coordinates are the average of the coordinates of the endpoints). To try your
      ;; procedures, you’ll need a way to print points:

      (define make-point
        (lambda (x y)
          (list x y)))

      (define x-point
        (lambda (point)
          (car point)))

      (define y-point
        (lambda (point)
          (car (cdr point))))

      (define make-segment
        (lambda (point-1 point-2)
          (list point-1 point-2)))

      (define start-segment
        (lambda (segment)
          (car segment)))

      (define end-segment
        (lambda (segment)
          (car (cdr segment))))

      (define (print-point p)
        (newline)
        (display "(")
        (display (x-point p))
        (display ",")
        (display (y-point p))
        (display ")"))

      (define average
        (lambda (a b)
          (/ (+ a b) 2)))

      (define midpoint-segment
        (lambda (segment)
          (let ((point-1 (start-segment segment))
                (point-2 (end-segment segment)))
            (let ((x1 (x-point point-1))
                  (x2 (x-point point-2))
                  (y1 (y-point point-1))
                  (y2 (y-point point-2)))
              (make-point (average x1 x2)
                          (average y1 y2))))))


      (make-point 1 2)

      (x-point (make-point 1 2))

      (y-point (make-point 1 2))

      (make-segment (make-point 1 2)
                    (make-point 2 3))

      (start-segment (make-segment (make-point 1 2)
                                   (make-point 2 3)))

      (end-segment (make-segment (make-point 1 2)
                                 (make-point 2 3)))

      (midpoint-segment (make-segment (make-point 1 2)
                                      (make-point 2 3)))
     #+END_SRC
3. [X] Exercise 2.3
   #+BEGIN_SRC scheme
     ;; Implement a representation for rectangles in a plane. (Hint: You may want to
     ;; make use of Exercise 2.2.) In terms of your constructors and selectors,
     ;; create procedures that compute the perimeter and the area of a given
     ;; rectangle. Now implement a different representation for rectangles. Can you
     ;; design your system with suitable abstraction barriers, so that the same
     ;; perimeter and area procedures will work using either representation?

     (define make-rectangle
       (lambda (top-left bottom-right)
         (list top-left bottom-right)))

     (define top-left
       (lambda (rect)
         (car rect)))

     (define bottom-right
       (lambda (rect)
         (car (cdr rect))))

     (define perimeter-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (+ (* 2 height)
                  (* 2 width)))))))

     (define area-rect
       (lambda (rect)
         (let ((top-left (top-left rect))
               (bottom-right (bottom-right rect)))
           (let ((x-left (x-point top-left))
                 (x-right (x-point bottom-right))
                 (y-top (y-point top-left))
                 (y-bottom (y-point bottom-right)))
             (let ((height (- y-top y-bottom))
                   (width (- x-right x-left)))
               (* height width))))))


     (make-rectangle (make-point 2 2)
                     (make-point 1 1))

     (top-left (make-rectangle (make-point 2 2)
                               (make-point 1 1)))

     (bottom-right (make-rectangle (make-point 2 2)
                                   (make-point 1 1)))


     (perimeter-rect (make-rectangle (make-point -3 2)
                                     (make-point 3 -8)))

     (area-rect (make-rectangle (make-point -3 2)
                                (make-point 3 -8)))
     #+END_SRC
4. [X] Exercise 2.4
   #+BEGIN_SRC scheme
     ;; Here is an alternative procedural representa- tion of pairs. For this
     ;; representation, verify that (car (cons x y)) yields x for any objects x and
     ;; y.

     (define (cons x y)
       (lambda (m) (m x y)))
              (define (car z)
                (z (lambda (p q) p)))

              (let ((a 1)
                    (b 2))
                (= (car (cons a b))
                   a)) ;; => #t

     ;; What is the corresponding definition of cdr? (Hint: To verify that this
     ;; works, make use of the substitution model of Section 1.1.5.)
     (define (cdr z)
       (z (lambda (p q) q)))

     (let ((a 1)
           (b 2))
       (= (cdr (cons a b))
          b))
     #+END_SRC
5. [X] Exercise 2.5
   #+BEGIN_SRC scheme
     ;; Show that we can represent pairs of non-negative integers using only numbers
     ;; and arithmetic operations if we represent the pair a and b as the integer
     ;; that is the product 2^a 3^b. Give the corresponding definitions of the
     ;; procedures cons, car, and cdr. I totally had to look this up online.
       (define (cons x y)
         (* (expt 2 x)
            (expt 3 y)))

       (define (log-reduce n base)
         (cond ((not (zero? (remainder n base))) 0)
               (else (+ (log-reduce (/ n base) base) 1))))

       (define (car z)
         (log-reduce z 2))

       (define (cdr z)
         (log-reduce z 3))

       (define test-pair (cons 11 7))
       (car test-pair) ;; => 11
       (cdr test-pair) ;; => 7
     #+END_SRC
6. [X] Exercise 2.6
   #+BEGIN_SRC scheme
     ;; In case representing pairs as procedures wasn’t mind-boggling enough,
     ;; consider that, in a language that can manipulate procedures, we can get by
     ;; without numbers (at least insofar as nonnegative integers are concerned) by
     ;; implementing 0 and the operation of adding 1 as
     (define zero
       (lambda (f)
         (lambda (x) x)))

     (define (add-1 n)
       (lambda (f)
         (lambda (x)
           (f ((n f) x)))))

     ;; This representation is known as Church numerals, after its inventor, Alonzo
     ;; Church, the logician who invented the λ-calculus.

     ;; Define one and two directly (not in terms of zero and add- 1). (Hint: Use
     ;; substitution to evaluate (add-1 zero)). Give a direct definition of the
     ;; addition procedure + (not in terms of repeated application of add-1).

     (define one
       (lambda (f)
         (lambda (x)
           (f x))))

     (define two
       (lambda (f)
         (lambda (x)
           (f (f x)))))

     ;; This is basic church encoding. If you put some effort in, you can see that
     ;; the composition of two church numbers are the same as addition. That's what
     ;; leads us to this result.

     (define (add a b)
       (lambda (f)
         (lambda (x)
           ((a f) ((b f) x)))))

       #+END_SRC
7. [X] Exercise 2.7
   #+BEGIN_SRC scheme
     ;; Setup
     (define (add-interval x y)
       (make-interval (+ (lower-bound x) (lower-bound y))
                      (+ (upper-bound x) (upper-bound y))))

     (define (mul-interval x y)
       (let ((p1 (* (lower-bound x) (lower-bound y)))
             (p2 (* (lower-bound x) (upper-bound y)))
             (p3 (* (upper-bound x) (lower-bound y)))
             (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))

     (define (div-interval x y)
       (mul-interval x
                     (make-interval (/ 1.0 (upper-bound y))
                                    (/ 1.0 (lower-bound y)))))

     ;; Alyssa's program is incomplete because she has not specified the
     ;; implementation of the interval abstraction. Here is a definition of the
     ;; interval constructor:

     (define (make-interval a b) (cons a b))

     ;; Define selectors upper-bound and lower-bound to complete the implementation.

     (define (make-interval a b) (cons a b))

     (define upper-bound
       (lambda (interval)
         (cdr interval)))

     (define lower-bound
       (lambda (interval)
         (car interval)))
   #+END_SRC
8. [X] Exercise 2.8
   #+BEGIN_SRC scheme
     ;; Using reasoning analogous to Alyssa's, describe how the difference of two
     ;; intervals may be computed. Define a corresponding subtraction procedure,
     ;; called sub-interval.
     (define sub-interval
       (lambda (x y)
         (let ((s1 (- (lower-bound x) (lower-bound y)))
               (s2 (- (lower-bound x) (upper-bound y)))
               (s3 (- (upper-bound x) (lower-bound y)))
               (s4 (- (upper-bound x) (upper-bound y))))
           (make-interval (min s1 s2 s3 s4)
                          (max s1 s2 s3 s4)))))


   #+END_SRC
9. [X] Exercise 2.9
   #+BEGIN_SRC scheme
     ;; The width of an interval is half of the difference between its upper and
     ;; lower bounds. The width is a measure of the uncertainty of the number
     ;; specified by the interval. For some arithmetic operations the width of the
     ;; result of combining two intervals is a function only of the widths of the
     ;; argument intervals, whereas for others the width of the combination is not a
     ;; function of the widths of the argument intervals. Show that the width of the
     ;; sum (or difference) of two intervals is a function only of the widths of the
     ;; intervals being added (or subtracted). Give examples to show that this is not
     ;; true for multiplication or division.

     (define interval-width
       (lambda (interval)
         (let ((difference (abs (- (lower-bound interval)
                                   (upper-bound interval)))))
           (/ difference 2))))

     (define same-width?
       (lambda (operation fn x y)
         (let ((width-x (interval-width x))
               (width-y (interval-width y))
               (width-res (interval-width (operation x y))))
           (= width-res (fn width-x width-y)))))

     (same-width? add-interval
                  +
                  (make-interval 3 4)
                  (make-interval 8 9))

     ;; add and subtract interval's width are both a function of +. Multiply and
     ;; divide return intervals are made by getting the minimum and the maximum of
     ;; the varients of the intervals. This means there is a loss of information
     ;; between the first and second intervals, and that information is necessary in
     ;; order to have a function that relates the two widths to the resulting width.
   #+END_SRC
10. [X] Exercise 2.10
    #+BEGIN_SRC scheme
      ;; Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
      ;; comments that it is not clear what it means to divide by an interval that
      ;; spans zero. Modify Alyssa's code to check for this condition and to signal an
      ;; error if it occurs.

      (define spans-zero?
        (lambda (x)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x)))
            (< (* x1 x2) 0))))

      (define (div-interval x y)
        (if (or (spans-zero? x)
                (spans-zero? y))
            'something-went-horribly-wrong
            (mul-interval x
                          (make-interval (/ 1.0 (upper-bound y))
                                         (/ 1.0 (lower-bound y))))))

      (list (div-interval (make-interval 3 4)
                          (make-interval -3 4))
            (div-interval (make-interval 3 4)
                          (make-interval -4 -3)))

    #+END_SRC
11. [X] Exercise 2.11
    #+BEGIN_SRC scheme
      ;; In passing, Ben also cryptically comments: ``By testing the signs of the
      ;; endpoints of the intervals, it is possible to break mul-interval into nine
      ;; cases, only one of which requires more than two multiplications.'' Rewrite
      ;; this procedure using Ben's suggestion.

      (define interval-makeup
        (lambda (interval)
          (let ((x1 (lower-bound interval))
                (x2 (upper-bound interval)))
            (cond
             ((and (< x1 0) (< x2 0)) -1)
             ((and (< x1 0) (< x2 0)) 0)
             (else 1)))))

      (define mul-interval
        (lambda (x y)
          (let ((x1 (lower-bound x))
                (x2 (upper-bound x))
                (y1 (lower-bound y))
                (y2 (lower-bound y))
                (sign-x (interval-makeup x))
                (sign-y (interval-makeup y)))
            (cond
             ((< sign-x 0) (cond
                            ;; - - - -
                            ((< sign-y 0) (make-interval (* x2 y2)
                                                         (* x1 y1)))
                            ;; - - - +
                            ((= sign-y 0) (make-interval (* x1 y2)
                                                         (* x1 y1)))
                            ;; - - + +
                            (else (make-interval (* x1 y2)
                                                 (* x2 y1)))))
             ((= sign 0) (cond
                          ;; - + - -
                          ((< sign-y 0) (make-interval (* x2 y1)
                                                       (* x1 y1)))
                          ;; - + - +
                          ((= sign-y 0) (make-interval (min (* x1 y2)
                                                            (* x2 y1))
                                                       (max (* x1 y1)
                                                            (* x2 y2))))
                          (else (make-interval (* x1 y2)
                                               (* x2 y2)))))
             (else (cond
                    ;; + + - -
                    ((< sign-y 0) (make-interval (* x2 y1)
                                                 (* x1 y2)))
                    ((= sign-y 0) (make-interval (* x2 y1)
                                                 (* x2 y2)))
                    (else (make-interval (* x1 y1)
                                         (* x2 y2)))))))))

      ;; After debugging her program, Alyssa shows it to a potential user, who
      ;; complains that her program solves the wrong problem. He wants a program that
      ;; can deal with numbers represented as a center value and an additive
      ;; tolerance; for example, he wants to work with intervals such as 3.5± 0.15
      ;; rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem
      ;; by supplying an alternate constructor and alternate selectors:

      (define (make-center-width c w)
        (make-interval (- c w) (+ c w)))
      (define (center i)
        (/ (+ (lower-bound i) (upper-bound i)) 2))
      (define (width i)
        (/ (- (upper-bound i) (lower-bound i)) 2))

      ;; Unfortunately, most of Alyssa's users are engineers. Real engineering
      ;; situations usually involve measurements with only a small uncertainty,
      ;; measured as the ratio of the width of the interval to the midpoint of the
      ;; interval. Engineers usually specify percentage tolerances on the parameters
      ;; of devices, as in the resistor specifications given earlier.
    #+END_SRC
12. [X] Exercise 2.12
    #+BEGIN_SRC scheme
      ;; Define a constructor make-center-percent that takes a center and a percentage
      ;; tolerance and produces the desired interval. You must also define a selector
      ;; percent that produces the percentage tolerance for a given interval. The
      ;; center selector is the same as the one shown above.

      (define (make-interval a b) (cons a b))
      (define (upper-bound interval) (max (car interval) (cdr interval)))
      (define (lower-bound interval) (min (car interval) (cdr interval)))
      (define (center i) (/ (+ (upper-bound i) (lower-bound i)) 2))

      (define (make-interval-center-percent c pct)
        (let ((width (* c (/ pct 100.0))))
          (make-interval (- c width) (+ c width))))

      (define (percent-tolerance i)
        (let ((center (/ (+ (upper-bound i) (lower-bound i)) 2.0))
              (width (/ (- (upper-bound i) (lower-bound i)) 2.0)))
          (* (/ width center) 100)))


      ;; A quick check:

      (define i (make-interval-center-percent 10 50))
      (list (lower-bound i)
            (upper-bound i)
            (center i)
            (percent-tolerance i))
    #+END_SRC
13. [X] Exercise 2.13
    #+BEGIN_SRC scheme
      ;; Show that under the assumption of small percentage tolerances there is a
      ;; simple formula for the approximate percentage tolerance of the product of two
      ;; intervals in terms of the tolerances of the factors. You may simplify the
      ;; problem by assuming that all numbers are positive.

      (define (make-interval a b) (cons a b))
      (define (upper-bound interval) (max (car interval) (cdr interval)))
      (define (lower-bound interval) (min (car interval) (cdr interval)))
      (define (center i) (/ (+ (upper-bound i) (lower-bound i)) 2))

      ;; Percent is between 0 and 100.0
      (define (make-interval-center-percent c pct)
        (let ((width (* c (/ pct 100.0))))
          (make-interval (- c width) (+ c width))))

      (define (percent-tolerance i)
        (let ((center (/ (+ (upper-bound i) (lower-bound i)) 2.0))
              (width (/ (- (upper-bound i) (lower-bound i)) 2.0)))
          (* (/ width center) 100)))

      (define (mul-interval x y)
        (let ((p1 (* (lower-bound x) (lower-bound y)))
              (p2 (* (lower-bound x) (upper-bound y)))
              (p3 (* (upper-bound x) (lower-bound y)))
              (p4 (* (upper-bound x) (upper-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4))))


      (define i (make-interval-center-percent 10 0.5))
      (define j (make-interval-center-percent 10 0.4))
      (percent-tolerance (mul-interval i j)) ;; => 0.899982... Very close to .9
    #+END_SRC
14. [X] Exercise 2.14
    #+BEGIN_SRC scheme
      ;; Demonstrate that Lem is right. Investigate the behavior of the system on a
      ;; variety of arithmetic expressions. Make some intervals A and B, and use them
      ;; in computing the expressions A/A and A/B. You will get the most insight by
      ;; using intervals whose width is a small percentage of the center value.
      ;; Examine the results of the computation in center-percent form (see exercise
      ;; 2.12).

      ;; A = [2, 8]
      ;; B = [2, 8]

      ;; A could be any number, such as 3.782, and B could be 5.42, but we just don't
      ;; know.

      ;; Now, A divided by itself must be 1.0 (assuming A isn't 0), but of A/B (the
      ;; same applies to subtraction) we can only say that it's somewhere in the
      ;; interval

      ;; [0.25, 4]

      ;; Unfortunately, our interval package doesn't say anything about identity, so
      ;; if we calculated A/A, we would also get

      ;; [0.25, 4]

      ;; So, any time we do algebraic manipulation of an equation involving intervals,
      ;; we need to be careful any time we introduce the same interval (e.g. through
      ;; fraction reduction), since our interval package re-introduces the
      ;; uncertainty, even if it shouldn't.
    #+END_SRC
15. [X] Exercise 2.15
    #+BEGIN_SRC scheme
      ;; Eva Lu Ator, another user, has also noticed the different intervals computed
      ;; by different but algebraically equivalent expressions. She says that a
      ;; formula to compute with intervals using Alyssa's system will produce tighter
      ;; error bounds if it can be written in such a form that no variable that
      ;; represents an uncertain number is repeated. Thus, she says, par2 is a
      ;; ``better'' program for parallel resistances than par1. Is she right? Why?

      ;; Eva is right, since the error isn't reintroduced into the result in par2 as
      ;; it is in par1.
    #+END_SRC
16. [X] Exercise 2.16
    #+BEGIN_SRC scheme
      ;; Explain, in general, why equivalent algebraic expressions may lead to
      ;; different answers. Can you devise an interval-arithmetic package that does
      ;; not have this shortcoming, or is this task impossible? (Warning: This problem
      ;; is very difficult.)

      ;; A fiendish question. They say it's "very difficult" as if it's doable. I'm
      ;; not falling for that. Essentially, I believe we'd have to introduce some
      ;; concept of "identity", and then have the program be clever enough to reduce
      ;; equations. Also, when supplying arguments to any equation, we'd need to
      ;; indicate identity somehow, since [2, 8] isn't necessarily the same as [2, 8]
    #+END_SRC
17. [X] Exercise 2.17
    #+BEGIN_SRC scheme
      ;; Define a procedure last-pair that returns the list that contains only the
      ;; last element of a given (nonempty) list:

      (define last-pair
        (lambda (l)
          (let ((len (length l)))
            (cond
             ((= len 1) l)
             (else (last-pair (cdr l)))))))

      (equal? (list 4) (last-pair (list 1 2 3 4)))
      (equal? (list 34) (last-pair (list 23 72 149 34)))
    #+END_SRC
18. [X] Exercise 2.18
    #+BEGIN_SRC scheme
      ;; Define a procedure reverse that takes a list as argument and returns a list
      ;; of the same elements in reverse order:

      (define (append list1 list2)
        (if (null? list1)
            list2
            (cons (car list1) (append (cdr list1) list2))))

      (define reverse
        (lambda (l)
          (cond
           ((null? l) l)
           (else (append (reverse (cdr l))
                         (list (car l)))))))

      (equal? (list 25 16 9 4 1)
              (reverse (list 1 4 9 16 25)))
    #+END_SRC
19. [X] Exercise 2.19
    #+BEGIN_SRC scheme
      ;; Consider the change-counting program of section 1.2.2. It would be nice to be
      ;; able to easily change the currency used by the program, so that we could
      ;; compute the number of ways to change a British pound, for example. As the
      ;; program is written, the knowledge of the currency is distributed partly into
      ;; the procedure first-denomination and partly into the procedure count-change
      ;; (which knows that there are five kinds of U.S. coins). It would be nicer to
      ;; be able to supply a list of coins to be used for making change.

      ;; We want to rewrite the procedure cc so that its second argument is a list of
      ;; the values of the coins to use rather than an integer specifying which coins
      ;; to use. We could then have lists that defined each kind of currency:

      (define us-coins (list 50 25 10 5 1))
      (define uk-coins (list 100 50 20 10 5 2 1 0.5))

      ;; We could then call cc as follows:

      ;; (cc 100 us-coins)

      ;; To do this will require changing the program cc somewhat. It will still have
      ;; the same form, but it will access its second argument differently, as
      ;; follows:

      (define first-denomination
        (lambda (coin-values)
          (car coin-values)))

      (define no-more?
        (lambda (coin-values)
          (null? coin-values)))

      (define except-first-denomination
        (lambda (coin-values)
          (cdr coin-values)))

      (define (cc amount coin-values)
        (cond ((= amount 0) 1)
              ((or (< amount 0) (no-more? coin-values)) 0)
              (else
               (+ (cc amount
                      (except-first-denomination coin-values))
                  (cc (- amount
                         (first-denomination coin-values))
                      coin-values)))))

      ;; Define the procedures first-denomination, except-first-denomination, and
      ;; no-more? in terms of primitive operations on list structures. Does the order
      ;; of the list coin-values affect the answer produced by cc? Why or why not?

      (cc 100 us-coins)

      ;; The answer is independent on the order of the coins. See this for an example

      (equal? (cc 25 uk-coins)
              (cc 25 (reverse uk-coins)))
    #+END_SRC
20. [X] Exercise 2.20
    #+BEGIN_SRC scheme
      ;; The procedures +, *, and list take arbitrary numbers of arguments. One way to
      ;; define such procedures is to use define with dotted-tail notation. In a
      ;; procedure definition, a parameter list that has a dot before the last
      ;; parameter name indicates that, when the procedure is called, the initial
      ;; parameters (if any) will have as values the initial arguments, as usual, but
      ;; the final parameter's value will be a list of any remaining arguments. For
      ;; instance, given the definition

      ;; (define (f x y . z) <body>)

      ;; the procedure f can be called with two or more arguments. If we evaluate

      ;; (f 1 2 3 4 5 6)

      ;; then in the body of f, x will be 1, y will be 2, and z will be the list (3 4
      ;; 5 6). Given the definition

      ;; (define (g . w) <body>)

      ;; the procedure g can be called with zero or more arguments. If we evaluate

      ;; (g 1 2 3 4 5 6)

      ;; then in the body of g, w will be the list (1 2 3 4 5 6).

      ;; Use this notation to write a procedure same-parity that takes one or more
      ;; integers and returns a list of all the arguments that have the same even-odd
      ;; parity as the first argument. For example,

      (define keep
        (lambda (pred l)
          (cond
           ((null? l) l)
           ((pred (car l)) (cons (car l)
                                 (keep pred (cdr l))))
           (else (keep pred (cdr l))))))

      (define same-parity
        (lambda (a . xs)
          (if (even? a)
              (keep even? (cons a xs))
              (keep odd? (cons a xs)))))

      (list (equal? (same-parity 1 2 3 4 5 6 7)
                    (list 1 3 5 7))
            (equal? (same-parity 2 3 4 5 6 7)
                    (list 2 4 6)))
  #+END_SRC
21. [X] Exercise 2.21
    #+BEGIN_SRC scheme
      ;; The procedure square-list takes a list of numbers as argument and returns a
      ;; list of the squares of those numbers.

      ;; Here are two different definitions of square-list. Complete both of them by
      ;; filling in the missing expressions:

      (define square
        (lambda (n)
          (* n n)))

      (define (square-list items)
        (if (null? items)
            '()
            (cons (square (car items))
                  (square-list (cdr items)))))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))

      (define (square-list items)
        (map square items))

      (equal? (square-list (list 1 2 3 4))
              (list 1 4 9 16))
    #+END_SRC
22. [X] Exercise 2.22
    #+BEGIN_SRC scheme
      ;; Louis Reasoner tries to rewrite the first square-list procedure of exercise
      ;; 2.21 so that it evolves an iterative process:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons (square (car things))
                          answer))))
        (iter items nil))

      ;; Unfortunately, defining square-list this way produces the answer list in the
      ;; reverse order of the one desired. Why?

      ;; This one doesn't work because cons adds the answer to the head of the list.
      ;; This causes us to iterate backwards from the direction we should go.

      ;; Louis then tries to fix his bug by interchanging the arguments to cons:

      (define (square-list items)
        (define (iter things answer)
          (if (null? things)
              answer
              (iter (cdr things)
                    (cons answer
                          (square (car things))))))
        (iter items nil))

      ;; This doesn't work either. Explain.

      ;; This doesn't work because we are consing onto an atom instead of a list.
    #+END_SRC
23. [X] Exercise 2.23
    #+BEGIN_SRC scheme
      ;; The procedure for-each is similar to map. It takes as arguments a procedure
      ;; and a list of elements. However, rather than forming a list of the results,
      ;; for-each just applies the procedure to each of the elements in turn, from
      ;; left to right. The values returned by applying the procedure to the elements
      ;; are not used at all -- for-each is used with procedures that perform an
      ;; action, such as printing. For example,

      (define for-each
        (lambda (proc data)
          (cond
           ((null? data) #t)
           (else (begin
                   (proc (car data))
                   (for-each proc (cdr data)))))))

      (for-each (lambda (x) (newline) (display x))
                (list 57 321 88))
      ;; 57
      ;; 321
      ;; 88

      ;; The value returned by the call to for-each (not illustrated above) can be
      ;; something arbitrary, such as true. Give an implementation of for-each.
    #+END_SRC
24. [X] Exercise 2.24
    #+BEGIN_SRC scheme
      ;; Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the
      ;; result printed by the interpreter, the corresponding box-and-pointer
      ;; structure, and the interpretation of this as a tree (as in figure 2.6).

      ;; I can't really draw since this is only text, but I'll do my best

      '(1 (2 (3 4)))

      [*] [*] ---> [*] [/]
       |            |
       v            v
      [1]          [*] [*] ---> [*] [/]
                    |            |
                    v            v
                   [2]          [*] [*] ---> [*] [/]
                                 |            |
                                 v            v
                                [3]          [4]

                        (list 1 (list 2 (list 3 4)))
                            /          \
                           1       (list 2 (list 3 4))
                                     /         \
                                    2        (list 3 4)
                                                /   \
                                               3     4
    #+END_SRC
25. [X] Exercise 2.25
    #+BEGIN_SRC scheme
      ;; Give combinations of cars and cdrs that will pick 7 from each of the
      ;; following lists:
      (car
       (cdr
        (car
         (cdr
          (cdr
           '(1 3 (5 7) 9)
           ) ;; (3 (5 7) 9)
          ) ;; ((5 7) 9)
         ) ;; (5 7)
        ) ;; (7)
       ) ;; 7

      (car
       (car
        '((7))
        ) ;; (7)
       ) ;; 7

      (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7))))))))))))))))))
    #+END_SRC
26. [X] Exercise 2.26
    #+BEGIN_SRC scheme
      ;; Suppose we define x and y to be two lists:

      (define x (list 1 2 3))
      (define y (list 4 5 6))

      ;; What result is printed by the interpreter in response to evaluating each of
      ;; the following expressions:

      (append x y) ;; => (1 2 3 4 5 6)

      (cons x y) ;; => ((1 2 3) 4 5 6)

      (list x y) ;; => ((1 2 3) (4 5 6))
    #+END_SRC
27. [X] Exercise 2.27
    #+BEGIN_SRC scheme
      ;; Modify your reverse procedure of exercise 2.18 to produce a deep-reverse
      ;; procedure that takes a list as argument and returns as its value the list
      ;; with its elements reversed and with all sublists deep-reversed as well. For
      ;; example,

      (define reverse
        (lambda (l)
          (cond
           ((null? l) l)
           (else (append (reverse (cdr l))
                         (list (car l)))))))

      (define (deep-reverse items)
        (define (iter items acc)
          (cond
           ((null? items) acc)
           ((list? (car items)) (iter (cdr items)
                                      (append (list (deep-reverse (car items))) acc)))
           (else (iter (cdr items)
                       (append (list (car items)) acc)))))
        (iter items '()))

      (define x (list (list 1 2) (list 3 4)))

      x ;; => ((1 2) (3 4))

      (reverse x) ;; => ((3 4) (1 2))

      (deep-reverse x) ;; => ((4 3) (2 1))

    #+END_SRC
28. [X] Exercise 2.28
    #+BEGIN_SRC scheme
      ;; Write a procedure fringe that takes as argument a tree (represented as a
      ;; list) and returns a list whose elements are all the leaves of the tree
      ;; arranged in left-to-right order. For example,

      (define fringe
        (lambda (tree)
          (cond
           ((null? tree) tree)

           ((list? (car tree)) (append (fringe (car tree))
                                       (fringe (cdr tree))))

           (else (cons (car tree)
                       (fringe (cdr tree)))))))

      (define x (list (list 1 2) (list 3 4)))

      (fringe x) ;; => (1 2 3 4)

      (fringe (list x x)) ;; => (1 2 3 4 1 2 3 4)
    #+END_SRC
29. [X] Exercise 2.29
    #+BEGIN_SRC scheme
      ;; A binary mobile consists of two branches, a left branch and a right branch.
      ;; Each branch is a rod of a certain length, from which hangs either a weight or
      ;; another binary mobile. We can represent a binary mobile using compound data
      ;; by constructing it from two branches (for example, using list):

      (define (make-mobile left right)
        (list left right))

      ;; A branch is constructed from a length (which must be a number) together with
      ;; a structure, which may be either a number (representing a simple weight) or
      ;; another mobile:

      (define (make-branch length structure)
        (list length structure))

      ;; a. Write the corresponding selectors left-branch and right-branch, which
      ;; return the branches of a mobile, and branch-length and branch-structure,
      ;; which return the components of a branch.

      (define first
        (lambda (l)
          (car l)))

      (define second
        (lambda (l)
          (first (cdr l))))

      (define left-branch
        (lambda (mobile)
          (first mobile)))

      (define right-branch
        (lambda (mobile)
          (second mobile)))

      (define branch-length
        (lambda (branch)
          (first branch)))

      (define branch-structure
        (lambda (branch)
          (second branch)))

      ;; b. Using your selectors, define a procedure total-weight that returns the
      ;; total weight of a mobile.

      (define total-weight
        (lambda (structure)
          (cond
           ((number? structure) structure)
           (else (let ((l-branch (left-branch structure))
                       (r-branch (right-branch structure)))
                   (let ((r-struct (branch-structure r-branch))
                         (l-struct (branch-structure l-branch)))
                     (+ (total-weight l-struct)
                        (total-weight r-struct))))))))

      ;; c. A mobile is said to be balanced if the torque applied by its top-left
      ;; branch is equal to that applied by its top-right branch (that is, if the
      ;; length of the left rod multiplied by the weight hanging from that rod is
      ;; equal to the corresponding product for the right side) and if each of the
      ;; submobiles hanging off its branches is balanced. Design a predicate that
      ;; tests whether a binary mobile is balanced.

      (define balanced-simple
        (make-mobile
         (make-branch 2 3)
         (make-branch 3 2)))

      (define balanced-complex
        (make-mobile
         (make-branch 2 (make-mobile
                         (make-branch 6 2)
                         (make-branch 3 4)))
         (make-branch 2 6)))

      (define unbalanced-simple
        (make-mobile
         (make-branch 2 3)
         (make-branch 3 200)))

      (define unbalanced-complex
        (make-mobile
         (make-branch 2 (make-mobile
                         (make-branch 6 2)
                         (make-branch 3 4)))
         (make-branch 2 60)))

      (define structure-mobile?
        (lambda (structure)
          (not (number? structure))))

      (define torque
        (lambda (branch)
          (* (total-weight (branch-structure branch))
             (branch-length branch))))

      (define mobile-balanced?
        (lambda (mobile)
          (let ((l-branch (left-branch mobile))
                (r-branch (right-branch mobile)))
            (let ((r-struct (branch-structure r-branch))
                  (l-struct (branch-structure l-branch)))
              (and (if (structure-mobile? r-struct) (mobile-balanced? r-struct) #t)
                   (if (structure-mobile? l-struct) (mobile-balanced? l-struct) #t)
                   (eq? (torque l-branch)
                        (torque r-branch)))))))

      ;; d. Suppose we change the representation of mobiles so that the constructors
      ;; are

      (define (make-mobile left right)
        (cons left right))
      (define (make-branch length structure)
        (cons length structure))

      ;; How much do you need to change your programs to convert to the new
      ;; representation?

      ;; All I need to change is the selectors.

      (define left-branch
        (lambda (mobile)
          (car mobile)))

      (define right-branch
        (lambda (mobile)
          (cdr mobile)))

      (define branch-length
        (lambda (branch)
          (car branch)))

      (define branch-structure
        (lambda (branch)
          (cdr branch)))


      ;; Mapping over trees

      ;; Just as map is a powerful abstraction for dealing with sequences, map
      ;; together with recursion is a powerful abstraction for dealing with trees. For
      ;; instance, the scale-tree procedure, analogous to scale-list of section 2.2.1,
      ;; takes as arguments a numeric factor and a tree whose leaves are numbers. It
      ;; returns a tree of the same shape, where each number is multiplied by the
      ;; factor. The recursive plan for scale-tree is similar to the one for
      ;; count-leaves:

      (define (scale-tree tree factor)
        (cond ((null? tree) nil)
              ((not (pair? tree)) (* tree factor))
              (else (cons (scale-tree (car tree) factor)
                          (scale-tree (cdr tree) factor)))))

      (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
                  10) ;; => (10 (20 (30 40) 50) (60 70))

      ;; Another way to implement scale-tree is to regard the tree as a sequence of
      ;; sub-trees and use map. We map over the sequence, scaling each sub-tree in
      ;; turn, and return the list of results. In the base case, where the tree is a
      ;; leaf, we simply multiply by the factor:

      (define (scale-tree tree factor)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (scale-tree sub-tree factor)
                   (* sub-tree factor)))
             tree))

      ;; Many tree operations can be implemented by similar combinations of sequence
      ;; operations and recursion.
    #+END_SRC
30. [X] Exercise 2.30
    #+BEGIN_SRC scheme
      ;; Define a procedure square-tree analogous to the square-list procedure of
      ;; exercise 2.21. That is, square-list should behave as follows:

      ;; Define square-tree both directly (i.e., without using any higher-order
      ;; procedures) and also by using map and recursion.

      (define square
        (lambda (num)
          (* num num)))

      (define (square-tree-1 tree)
        (cond ((null? tree) '())
              ((not (pair? tree)) (square tree))
              (else (cons (square-tree-1 (car tree))
                          (square-tree-1 (cdr tree))))))

      (square-tree-1
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7))) ;; => (1 (4 (9 16) 25) (36 49))

      (define (square-tree-2 tree)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (square-tree-2 sub-tree)
                   (square sub-tree)))
             tree))

      (square-tree-2
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7))) ;; => (1 (4 (9 16) 25) (36 49))


    #+END_SRC
31. [X] Exercise 2.31
    #+BEGIN_SRC scheme
      ;; Abstract your answer to exercise 2.30 to produce a procedure tree-map with
      ;; the property that square-tree could be defined as

      (define (tree-map fn tree)
        (map (lambda (sub-tree)
               (if (pair? sub-tree)
                   (tree-map fn sub-tree)
                   (fn sub-tree)))
             tree))

      (define square
        (lambda (n)
          (* n n)))

      (define (square-tree tree) (tree-map square tree))
    #+END_SRC
32. [X] Exercise 2.32
    #+BEGIN_SRC scheme
      ;; We can represent a set as a list of distinct elements, and we can represent
      ;; the set of all subsets of the set as a list of lists. For example, if the set
      ;; is (1 2 3), then the set of all subsets is (() (3) (2) (2 3) (1) (1 3) (1 2)
      ;; (1 2 3)). Complete the following definition of a procedure that generates the
      ;; set of subsets of a set and give a clear explanation of why it works:

      (define (subsets s)
        (if (null? s)
            (list '())
            (let ((rest (subsets (cdr s))))
              (append rest (map
                            (lambda (x)
                              (append (list (car s)) x))
                            rest)))))

      ;; 1. Let's think about what rest will be the first time it's called with '(1 2
      ;; 3). rest will be the subsets of '(2 3). Now lets see what that will be.

      ;; 2. Let's think about what rest will be ... '(2 3). rest will be the subsets
      ;; of '(3). Now let's see what that will be.

      ;; 3. Let's think about what rest will be ... '(3). rest will be the subsets of
      ;; '(). We know the answer to this. It's '(()).

      ;; 4. Now we can go back to step 2 and continue with the second half. With rest
      ;; being '(()), we will fill in the code as follows.
      (append '(()) (map
                     (lambda (x)
                       (append (list (car '(3))) x))
                     '(())))
      ;; Since we're only mapping over one piece of data, let's go ahead and replace
      ;; into this one.
      (lambda ( '(3) )
        (append (list (car '(3))) '()))

      (append (list (car '(3))) '())

      (append (list 3) '())
      (append '(3) '())
      ;; And now that map is done, we append rest with '(3)
      (append '(()) '(3)) ;; => '(() (3))
      ;; This gives us '(() (3)) which are the subsets of '(3).

      ;; If you follow this same line of logic, you can see why mapping over (() (3))
      ;; and then appending that will give us the subsets of '(2 3). Following this
      ;; logic further leads up to getting the subsets of '(1 2 3)

      (subsets '(1 2 3))
    #+END_SRC
33. [X] Exercise 2.33
    #+BEGIN_SRC scheme
      ;; Fill in the missing expressions to complete the following definitions of some
      ;; basic list-manipulation operations as accumulations:

      (define (filter predicate sequence)
        (cond ((null? sequence) '())
              ((predicate (car sequence))
               (cons (car sequence)
                     (filter predicate (cdr sequence))))
              (else (filter predicate (cdr sequence)))))

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (map p sequence)
        (accumulate (lambda (x y)
                      (cons (p x) y)) '() sequence))

      (define (append seq1 seq2)
        (accumulate cons seq2 seq1))

      (define (length sequence)
        (accumulate (lambda (x y)
                      (+ y 1)) 0 sequence))
    #+END_SRC
34. [X] Exercise 2.34
    #+BEGIN_SRC scheme
      ;; Evaluating a polynomial in x at a given value of x can be formulated as an
      ;; accumulation. In other words, we start with an, multiply by x, add an-1,
      ;; multiply by x, and so on, until we reach a0.16 Fill in the following template
      ;; to produce a procedure that evaluates a polynomial using Horner's rule.
      ;; Assume that the coefficients of the polynomial are arranged in a sequence,
      ;; from a0 through an.
      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (horner-eval x coefficient-sequence)
        (accumulate (lambda (this-coeff higher-terms)
                      (+ this-coeff
                         (* higher-terms x)))
                    0
                    coefficient-sequence))

      ;; For example, to compute 1 + 3x + 5x3 + x5 at x = 2 you would evaluate

      (horner-eval 2 (list 1 3 0 5 0 1))
    #+END_SRC
35. [X] Exercise 2.35
    #+BEGIN_SRC scheme
      ;; Redefine count-leaves from section 2.2.2 as an accumulation:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (count-leaves t)
        (accumulate + 0 (map (lambda (tree)
                               (if (pair? tree)
                                   (count-leaves tree)
                                   1)) t)))

      (define x (cons (list 1 2) (list 3 4)))
      (count-leaves (list x x)) ;; => 8
    #+END_SRC
36. [X] Exercise 2.36
    #+BEGIN_SRC scheme
      ;; The procedure accumulate-n is similar to accumulate except that it takes as
      ;; its third argument a sequence of sequences, which are all assumed to have the
      ;; same number of elements. It applies the designated accumulation procedure to
      ;; combine all the first elements of the sequences, all the second elements of
      ;; the sequences, and so on, and returns a sequence of the results. For
      ;; instance, if s is a sequence containing four sequences, ((1 2 3) (4 5 6) (7 8
      ;; 9) (10 11 12)), then the value of (accumulate-n + 0 s) should be the sequence
      ;; (22 26 30). Fill in the missing expressions in the following definition of
      ;; accumulate-n:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (accumulate-n op init seqs)
        (if (null? (car seqs))
            '()
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))

      (accumulate-n + 0 '((1  2  3)
                          (4  5  6)
                          (7  8  9)
                          (10 11 12)))
    #+END_SRC
37. [X] Exercise 2.37
    #+BEGIN_SRC scheme
      ;; Suppose we represent vectors v = (vi) as sequences of numbers, and matrices m
      ;; = (mij) as sequences of vectors (the rows of the matrix). For example, the
      ;; matrix

      ;; 1 2 3 4
      ;; 4 5 6 6
      ;; 6 7 8 9

      ;; is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)). With this
      ;; representation, we can use sequence operations to concisely express the basic
      ;; matrix and vector operations. These operations (which are described in any
      ;; book on matrix algebra) are the following:

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (accumulate-n op init seqs)
        (if (null? (car seqs))
            '()
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))

      ;; We can define the dot product as
      (define (dot-product v w)
        (accumulate + 0 (map * v w)))

      (print (dot-product '(1 2 3)
                          '(1 2 3)))

      ;; Fill in the missing expressions in the following procedures for computing the
      ;; other matrix operations. (The procedure accumulate-n is defined in exercise
      ;; 2.36.)

      (define (matrix-*-vector m v)
        (map (lambda (row)
               (dot-product row v)) m))

      (print (matrix-*-vector '((1 2 3)
                                (4 5 6)
                                (7 8 9))
                              '(1 2 3)))

      (define (transpose mat)
        (accumulate-n cons '() mat))

      (print (transpose '((1 2 3)
                          (4 5 6)
                          (7 8 9))))

      (define (matrix-*-matrix m n)
        (let ((cols (transpose n)))
          (map (lambda (x)
                 (map (lambda (y)
                        (dot-product x y))
                      cols))
               m)))

      (print (matrix-*-matrix '((1 2 3)
                                (2 3 4))
                              '((2 3 4)
                                (5 7 9)
                                (4 9 1))))
    #+END_SRC
38. [X] Exercise 2.38
    #+BEGIN_SRC scheme
      ;; The accumulate procedure is also known as fold-right, because it combines
      ;; the first element of the sequence with the result of combining all the
      ;; elements to the right. There is also a fold-left, which is similar to
      ;; fold-right, except that it combines elements working in the opposite
      ;; direction:

      (define (fold-left op initial sequence)
        (define (iter result rest)
          (if (null? rest)
              result
              (iter (op result (car rest))
                    (cdr rest))))
        (iter initial sequence))

      ;; What are the values of

      (print (fold-right / 1 (list 1 2 3))) ;; => 1.5
      (print (fold-left / 1 (list 1 2 3))) ;; => .166...
      (print (fold-right list '() (list 1 2 3))) ;; => (1 (2 (3 ())))
      (print (fold-left list '() (list 1 2 3))) ;; => (((() 1) 2) 3)

      ;; Give a property that op should satisfy to guarantee that fold-right and
      ;; fold-left will produce the same values for any sequence.

      ;; the associative property
    #+END_SRC
39. [X] Exercise 2.39.
    #+BEGIN_SRC scheme
      ;; Complete the following definitions of reverse (exercise 2.18) in terms of
      ;; fold-right and fold-left from exercise 2.38:

      (define (reverse sequence)
        (fold-right (lambda (x y)
                      (append y (list x)))
                    '() sequence))

      (print (reverse '(1 2 3)))

      (define (reverse sequence)
        (fold-left (lambda (x y)
                     (append (list y) x)
                     ) '() sequence))

      (print (reverse '(1 2 3)))

      ;; Nested Mappings

      ;; We can extend the sequence paradigm to include many computations that are
      ;; commonly expressed using nested loops.18 Consider this problem: Given a
      ;; positive integer n, find all ordered pairs of distinct positive integers i
      ;; and j, where 1< j< i< n, such that i + j is prime. For example, if n is 6,
      ;; then the pairs are the following:

      ;; |-----+---+---+---+---+---+---+----|
      ;; | i   | 2 | 3 | 4 | 4 | 5 | 6 |  6 |
      ;; | j   | 1 | 2 | 1 | 3 | 2 | 1 |  5 |
      ;; |-----+---+---+---+---+---+---+----|
      ;; | i+j | 3 | 5 | 5 | 7 | 7 | 7 | 11 |
      ;; |-----+---+---+---+---+---+---+----|

      ;; A natural way to organize this computation is to generate the sequence of all
      ;; ordered pairs of positive integers less than or equal to n, filter to select
      ;; those pairs whose sum is prime, and then, for each pair (i, j) that passes
      ;; through the filter, produce the triple (i,j,i + j).

      ;; Here is a way to generate the sequence of pairs: For each integer i< n,
      ;; enumerate the integers j<i, and for each such i and j generate the pair
      ;; (i,j). In terms of sequence operations, we map along the sequence
      ;; (enumerate-interval 1 n). For each i in this sequence, we map along the
      ;; sequence (enumerate-interval 1 (- i 1)). For each j in this latter sequence,
      ;; we generate the pair (list i j). This gives us a sequence of pairs for each
      ;; i. Combining all the sequences for all the i (by accumulating with append)
      ;; produces the required sequence of pairs:19

      (accumulate append
                  '()
                  (map (lambda (i)
                         (map (lambda (j) (list i j))
                              (enumerate-interval 1 (- i 1))))
                       (enumerate-interval 1 n)))

      ;; The combination of mapping and accumulating with append is so common in this
      ;; sort of program that we will isolate it as a separate procedure:

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      ;; Now filter this sequence of pairs to find those whose sum is prime. The
      ;; filter predicate is called for each element of the sequence; its argument is
      ;; a pair and it must extract the integers from the pair. Thus, the predicate to
      ;; apply to each element in the sequence is

      (define (prime-sum? pair)
        (prime? (+ (car pair) (cadr pair))))

      ;; Finally, generate the sequence of results by mapping over the filtered pairs
      ;; using the following procedure, which constructs a triple consisting of the
      ;; two elements of the pair along with their sum:

      (define (make-pair-sum pair)
        (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

      ;; Combining all these steps yields the complete procedure:

      (define (prime-sum-pairs n)
        (map make-pair-sum
             (filter prime-sum?
                     (flatmap
                      (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))))

      ;; Nested mappings are also useful for sequences other than those that enumerate
      ;; intervals. Suppose we wish to generate all the permutations of a set S; that
      ;; is, all the ways of ordering the items in the set. For instance, the
      ;; permutations of {1,2,3} are {1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2},
      ;; and { 3,2,1}. Here is a plan for generating the permutations of S: For each
      ;; item x in S, recursively generate the sequence of permutations of S - x,20
      ;; and adjoin x to the front of each one. This yields, for each x in S, the
      ;; sequence of permutations of S that begin with x. Combining these sequences
      ;; for all x gives all the permutations of S:21

      (define (permutations s)
        (if (null? s)                    ; empty set?
            (list '())                   ; sequence containing empty set
            (flatmap (lambda (x)
                       (map (lambda (p) (cons x p))
                            (permutations (remove x s))))
                     s)))

      ;; Notice how this strategy reduces the problem of generating permutations of S
      ;; to the problem of generating the permutations of sets with fewer elements
      ;; than S. In the terminal case, we work our way down to the empty list, which
      ;; represents a set of no elements. For this, we generate (list '()), which is a
      ;; sequence with one item, namely the set with no elements. The remove procedure
      ;; used in permutations returns all the items in a given sequence except for a
      ;; given item. This can be expressed as a simple filter:

      (define (remove item sequence)
        (filter (lambda (x) (not (= x item)))
                sequence))
    #+END_SRC
40. [X] Exercise 2.40
    #+BEGIN_SRC scheme
      ;; Define a procedure unique-pairs that, given an integer n, generates the
      ;; sequence of pairs (i,j) with 1< j< i< n. Use unique-pairs to simplify the
      ;; definition of prime-sum-pairs given above.

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      (define enumerate-interval
        (lambda (from to)
          (cond
           ((>= from to) '())
           (else (cons from (enumerate-interval (+ from 1) to))))))

      (define unique-pairs
        (lambda (n)
          (flatmap (lambda (i)
                     (map (lambda (j)
                            (list i j))
                          (enumerate-interval 1 i)))
                   (enumerate-interval 1 n))))
    #+END_SRC
41. [X] Exercise 2.41
    #+BEGIN_SRC scheme
      ;; Write a procedure to find all ordered triples of distinct positive integers
      ;; i, j, and k less than or equal to a given integer n that sum to a given
      ;; integer s.

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (flatmap proc seq)
        (accumulate append '() (map proc seq)))

      (define enumerate-interval
        (lambda (from to)
          (cond
           ((>= from to) '())
           (else (cons from (enumerate-interval (+ from 1) to))))))


      (define first car)
      (define second cadr)
      (define third caddr)

      (define valid-triplets
        (lambda (n)
          (flatmap (lambda (i)
                     (flatmap (lambda (j)
                                (map (lambda (k)
                                       (list i j k))
                                     (enumerate-interval 1 n)))
                              (enumerate-interval 1 n)))
                   (enumerate-interval 1 n))))

      (define sum-to-s?
        (lambda (s triplet)
          (lambda (triplet)
            (eq? s (+ (first triplet)
                      (second triplet)
                      (third triplet))))))

      (define distinct-triplet?
        (lambda (triplet)
          (let ((a (first triplet))
                (b (second triplet))
                (c (third triplet)))
            (and (not (eq? a b))
                 (not (eq? b c))
                 (not (eq? a c))))))

      (define problem-proc
        (lambda (s n)
          (filter (sum-to-s? s)
                  (filter distinct-triplet? (valid-triplets n)))))

      (problem-proc 6 10)
    #+END_SRC
42. [X] Exercise 2.42.
    [[./eight-queeens.gif]]
    #+BEGIN_SRC scheme
      ;; The ``eight-queens puzzle'' asks how to place eight queens on a chessboard so
      ;; that no queen is in check from any other (i.e., no two queens are in the same
      ;; row, column, or diagonal). One possible solution is shown in figure 2.8. One
      ;; way to solve the puzzle is to work across the board, placing a queen in each
      ;; column. Once we have placed k - 1 queens, we must place the kth queen in a
      ;; position where it does not check any of the queens already on the board. We
      ;; can formulate this approach recursively: Assume that we have already
      ;; generated the sequence of all possible ways to place k - 1 queens in the
      ;; first k - 1 columns of the board. For each of these ways, generate an
      ;; extended set of positions by placing a queen in each row of the kth column.
      ;; Now filter these, keeping only the positions for which the queen in the kth
      ;; column is safe with respect to the other queens. This produces the sequence
      ;; of all ways to place k queens in the first k columns. By continuing this
      ;; process, we will produce not only one solution, but all solutions to the
      ;; puzzle.

      ;; We implement this solution as a procedure queens, which returns a sequence of
      ;; all solutions to the problem of placing n queens on an n× n chessboard.
      ;; Queens has an internal procedure queen-cols that returns the sequence of all
      ;; ways to place queens in the first k columns of the board.

      (define flatmap
        (lambda (proc seq)
          (fold-left append '()
                     (map proc seq))))

      (define (enumerate-interval low high)
        (if (> low high)
            '()
            (cons low (enumerate-interval (+ low 1) high))))

      (define (make-position row col)
        (cons row col))

      (define (position-row position)
        (car position))

      (define (position-col position)
        (cdr position))

      (define empty-board '())

      (define (adjoin-position row col positions)
        (append positions (list (make-position row col))))


      (define (safe? col positions)
        (let ((kth-queen (list-ref positions (- col 1)))
              (other-queens (filter (lambda (q)
                                      (not (= col (position-col q))))
                                    positions)))
          (define (attacks? q1 q2)
            (or (= (position-row q1) (position-row q2))
                (= (abs (- (position-row q1) (position-row q2)))
                   (abs (- (position-col q1) (position-col q2))))))

          (define (iter q board)
            (or (null? board)
                (and (not (attacks? q (car board)))
                     (iter q (cdr board)))))
          (iter kth-queen other-queens)))

      (define (queens board-size)
        (define (queen-cols k)
          (if (= k 0)
              (list empty-board)
              (filter
               (lambda (positions) (safe? k positions))
               (flatmap
                (lambda (rest-of-queens)
                  (map (lambda (new-row)
                         (adjoin-position new-row k rest-of-queens))
                       (enumerate-interval 1 board-size)))
                (queen-cols (- k 1))))))
        (queen-cols board-size))

      ;; In this procedure rest-of-queens is a way to place k - 1 queens in the first
      ;; k - 1 columns, and new-row is a proposed row in which to place the queen for
      ;; the kth column. Complete the program by implementing the representation for
      ;; sets of board positions, including the procedure adjoin-position, which
      ;; adjoins a new row-column position to a set of positions, and empty-board,
      ;; which represents an empty set of positions. You must also write the procedure
      ;; safe?, which determines for a set of positions, whether the queen in the kth
      ;; column is safe with respect to the others. (Note that we need only check
      ;; whether the new queen is safe -- the other queens are already guaranteed safe
      ;; with respect to each other.)
    #+END_SRC
43. [X] Exercise 2.43
    #+BEGIN_SRC scheme
      ;; Louis Reasoner is having a terrible time doing exercise 2.42. His queens
      ;; procedure seems to work, but it runs extremely slowly. (Louis never does
      ;; manage to wait long enough for it to solve even the 6× 6 case.) When Louis
      ;; asks Eva Lu Ator for help, she points out that he has interchanged the order
      ;; of the nested mappings in the flatmap, writing it as

      (flatmap
       (lambda (new-row)
         (map (lambda (rest-of-queens)
                (adjoin-position new-row k rest-of-queens))
              (queen-cols (- k 1))))
       (enumerate-interval 1 board-size))

      ;; Explain why this interchange makes the program run slowly. Estimate how long
      ;; it will take Louis's program to solve the eight-queens puzzle, assuming that
      ;; the program in exercise 2.42 solves the puzzle in time T.

      ;; The problem is that this one grows exponentially because by switching the
      ;; order we changed this to be a tree recursive process instead of a linear
      ;; recursive process like before.
    #+END_SRC
44. [X] Exercise 2.44
    #+BEGIN_SRC scheme
      ;; Define the procedure up-split used by corner-split. It is similar to
      ;; right-split, except that it switches the roles of below and beside.

      (define up-split
        (lambda painter n
                (if (= n 0)
                    painter
                    (let ((smaller (up-split painter (- n 1))))
                      (below painter (beside smaller smaller))))))
    #+END_SRC
45. [X] Exercise 2.45
    #+BEGIN_SRC scheme
      ;; Right-split and up-split can be expressed as instances of a general splitting
      ;; operation. Define a procedure split with the property that evaluating

      (define split
        (lambda (original-placer split-placer)
          (lambda (painter n)
            (cond
             ((= n 0) painter)
             (else (let ((smaller ((split original-placer
                                          split-placer)
                                   painter (- n 1))))
                     (original-placer painter (split-painter smaller smaller))))))))

      (define right-split (split beside below))
      (define up-split (split below beside))
    #+END_SRC
46. [X] Exercise 2.46
    #+BEGIN_SRC scheme
      ;; A two-dimensional vector v running from the origin to a point can be
      ;; represented as a pair consisting of an x-coordinate and a y-coordinate.
      ;; Implement a data abstraction for vectors by giving a constructor make-vect
      ;; and corresponding selectors xcor-vect and ycor-vect. In terms of your
      ;; selectors and constructor, implement procedures add-vect, sub-vect, and
      ;; scale-vect that perform the operations vector addition, vector subtraction,
      ;; and multiplying a vector by a scalar:

      (define make-vect
        (lambda (x-coord y-coord)
          (cons x-coord y-coord)))

      (define xcor-vect
        (lambda (vector)
          (car vector)))

      (define ycor-vect
        (lambda (vector)
          (cdr vector)))

      (define add-vect
        (lambda (vector-1 vector-2)
          (make-vect (+ (xcor-vect vector-1)
                        (xcor-vect vector-2))
                     (+ (ycor-vect vector-1)
                        (ycor-vect vector-2)))))

      (define sub-vect
        (lambda (vector-1 vector-2)
          (make-vect (- (xcor-vect vector-1)
                        (xcor-vect vector-2))
                     (- (ycor-vect vector-1)
                        (ycor-vect vector-2)))))

      (define scale-vec
        (lambda (vector scaling-factor)
          (make-vect (* (xcor-vect vector)
                        scaling-factor)
                     (* (ycor-vect vector)
                        scaling-factor))))

      (list

       (add-vect (make-vect 0 0)
                 (make-vect 2 -10))

       (sub-vect (make-vect 1 1)
                 (make-vect 2 -10))

       (scale-vec (make-vect 2 -3)
                  7.5)

       )
    #+END_SRC
47. [X] Exercise 2.47
    #+BEGIN_SRC scheme
      ;; Here are two possible constructors for frames:

      (define (make-frame origin edge1 edge2)
        (list origin edge1 edge2))

      (define select-origin
        (lambda (frame)
          (car frame)))

      (define select-edge-1
        (lambda (frame)
          (cadr frame)))

      (define select-edge-2
        (lambda (frame)
          (caddr frame)))

      ;; 2

      (define (make-frame origin edge1 edge2)
        (cons origin (cons edge1 edge2)))

      (define select-origin
        (lambda (frame)
          (car frame)))

      (define select-edge-1
        (lambda (frame)
          (cadr frame)))

      (define select-edge-2
        (lambda (frame)
          (cdadr frame)))

      ;; For each constructor supply the appropriate selectors to produce an
      ;; implementation for frames.
    #+END_SRC
48. [X] Exercise 2.48
    #+BEGIN_SRC scheme
      ;; A directed line segment in the plane can be represented as a pair of vectors
      ;; -- the vector running from the origin to the start-point of the segment, and
      ;; the vector running from the origin to the end-point of the segment. Use your
      ;; vector representation from exercise 2.46 to define a representation for
      ;; segments with a constructor make-segment and selectors start-segment and
      ;; end-segment.

      (define make-vect
        (lambda (x-coord y-coord)
          (cons x-coord y-coord)))

      (define xcor-vect
        (lambda (vector)
          (car vector)))

      (define ycor-vect
        (lambda (vector)
          (cdr vector)))

      (define make-segment
        (lambda (start end)
          (cons start end)))

      (define start-segment
        (lambda (segment)
          (car segment)))

      (define end-segment
        (lambda (segment)
          (cdr segment)))

      (make-segment (make-vec 1 1)
                    (make-vec 2 2))
    #+END_SRC
49. [X] Exercise 2.49
    #+BEGIN_SRC scheme
      (define make-vect
        (lambda (x-coord y-coord)
          (cons x-coord y-coord)))

      (define xcor-vect
        (lambda (vector)
          (car vector)))

      (define ycor-vect
        (lambda (vector)
          (cdr vector)))

      (define make-segment
        (lambda (start end)
          (cons start end)))

      (define start-segment
        (lambda (segment)
          (car segment)))

      (define end-segment
        (lambda (segment)
          (cdr segment)))

      (define tl (make-vect 0 1))
      (define tr (make-vect 1 1))
      (define bl (make-vect 0 0))
      (define br (make-vect 1 0))

      ;; Use segments->painter to define the following primitive painters:

      ;; a. The painter that draws the outline of the designated frame.
      (segments->painter (list
                          (make-segment bl tl)
                          (make-segment tl tr)
                          (make-segment tr br)
                          (make-segment br bl)))

      ;; b. The painter that draws an ``X'' by connecting opposite corners of the
      ;; frame.
      (segments->painter (list
                          (make-segment bl tr)
                          (make-segment br tl)))

      ;; c. The painter that draws a diamond shape by connecting the midpoints of the
      ;; sides of the frame.
      (define l (make-vect 0 0.5))
      (define t (make-vect 0.5 1))
      (define r (make-vect 1 0.5))
      (define b (make-vect 0.5 0))
      (segments->painter (list
                          (make-segment l t)
                          (make-segment t r)
                          (make-segment r b)
                          (make-segment b l)))
    #+END_SRC
50. [X] Exercise 2.50
    #+BEGIN_SRC scheme
      ;; Define the transformation flip-horiz, which flips painters horizontally, and
      ;; transformations that rotate painters counterclockwise by 180 degrees and 270
      ;; degrees.

      (define (transform-painter painter origin corner1 corner2)
        (lambda (frame)
          (let ((m (frame-coord-map frame)))
            (let ((new-origin (m origin)))
              (painter
               (make-frame new-origin
                           (sub-vect (m corner1) new-origin)
                           (sub-vect (m corner2) new-origin)))))))

      (define flip-horiz
        (lambda (painter)
          (transform-painter painter
                             (make-vect 1.0 0.0)
                             (make-vect 0.0 0.0)
                             (make-vect 1.0 1.0))))

      (define rotate180
        (lambda (painter)
          (transform-painter painter
                             (make-vect 1.0 1.0)
                             (make-vect 0.0 1.0)
                             (make-vect 1.0 0.0))))

      (define rotate270
        (lambda (painter)
          (transform-painter painter
                             (make-vect 0.0 1.0)
                             (make-vect 0.0 0.0)
                             (make-vect 1.0 1.0))))
    #+END_SRC
51. [X] Exercise 2.51
    #+BEGIN_SRC scheme
      ;; Define the below operation for painters. Below takes two painters as
      ;; arguments. The resulting painter, given a frame, draws with the first painter
      ;; in the bottom of the frame and with the second painter in the top. Define
      ;; below in two different ways -- first by writing a procedure that is analogous
      ;; to the beside procedure given above, and again in terms of beside and
      ;; suitable rotation operations (from exercise 2.50).

      (define below
        (lambda (painter1 painter2)
          (let ((split-point (make-vect 0.0 0.5)))
            (let ((paint-bottom
                   (transform-painter painter1
                                      (make-vect 0.0 0.0)
                                      (make-vect 1.0 0.0)
                                      split-point))
                  (paint-top
                   (transform-painter painter2
                                      split-point
                                      (make-vect 1.0 0.5)
                                      (make-vect 0.0 1.0))))
              (lambda (frame)
                (paint-bottom frame)
                (paint-top frame))))))

      (define below-2
        (lambda (painter1 painter2)
          (rotate90 (beside (rotate270 painter1) (rotate270 painter2)))))
    #+END_SRC
52. [X] Exercise 2.51
    #+BEGIN_SRC scheme
      ;; Make changes to the square limit of wave shown in figure 2.9 by working at
      ;; each of the levels described above. In particular:

      ;; a. Add some segments to the primitive wave painter of exercise 2.49 (to add a
      ;; smile, for example).
      (define wave
        (segments->painter (list
                            ;; Nah...
                            (make-segment (make-vect 0.44 0.7) (make-vect 0.51 0.7)))))

      ;; b. Change the pattern constructed by corner-split (for example, by using only
      ;; one copy of the up-split and right-split images instead of two).
      (define (corner-split painter n)
        (if (= n 0)
            painter
            (beside (below painter (up-split painter (- n 1)))
                    (below (right-split painter (- n 1)) (corner-split painter (- n 1))))))

      ;; c. Modify the version of square-limit that uses square-of-four so as to
      ;; assemble the corners in a different pattern. (For example, you might make the
      ;; big Mr. Rogers look outward from each corner of the square.)
      (define (square-limit painter n)
        (let ((combine4 (square-of-four flip-vert rotate180
                                        identity flip-horiz)))
          (combine4 (corner-split painter n))))
    #+END_SRC
53. [X] Exercise 2.53
    #+BEGIN_SRC scheme
      ;; What would the interpreter print in response to evaluating each of the
      ;; following expressions?

      (list 'a 'b 'c) ;; => (a b c)

      (list (list 'george)) ;; => ((george))

      (cdr '((x1 x2) (y1 y2))) ;; => ((y1 y2))

      (cadr '((x1 x2) (y1 y2))) ;; => (y1 y2)

      (pair? (car '(a short list))) ;; => #f

      (memq 'red '((red shoes) (blue socks))) ;; => #f

      (memq 'red '(red shoes blue socks)) ;; => (red shoes blue socks)
    #+END_SRC
54. [X] Exercise 2.54
    #+BEGIN_SRC scheme
      ;; Two lists are said to be equal? if they contain equal elements arranged in
      ;; the same order. For example,

      (equal? '(this is a list) '(this is a list))

      ;; is true, but

      (equal? '(this is a list) '(this (is a) list))

      ;; is false. To be more precise, we can define equal? recursively in terms of
      ;; the basic eq? equality of symbols by saying that a and b are equal? if they
      ;; are both symbols and the symbols are eq?, or if they are both lists such that
      ;; (car a) is equal? to (car b) and (cdr a) is equal? to (cdr b). Using this
      ;; idea, implement equal? as a procedure.

      (define equal?
        (lambda (l1 l2)
          (cond
           ((null? l1) (null? l2))
           ((and (symbol? (car l1))
                 (symbol? (car l2))) (and (eq? (car l1)
                                               (car l2))
                                          (equal? (cdr l1)
                                                  (cdr l2))))
           ((and (pair? (car l1))
                 (pair? (car l2))) (and (equal? (car l1)
                                                (car l2))
                                        (equal? (cdr l1)
                                                (cdr l2))))
           (else #f))))

      (list (equal? '(this is a list) '(this is a list))
            (equal? '(this is a list) '(this (is a) list)))
    #+END_SRC
55. [X] Exercise 2.55
    #+BEGIN_SRC scheme
      ;; Eva Lu Ator types to the interpreter the expression

      (car ''abracadabra)

      ;; To her surprise, the interpreter prints back quote. Explain.

      ;; If you get rid of one of the quotes and evaluate 'abacadabra, you get back
      ;; the symbol abacadabra, if you quote this, you get back (quote abracadabra).
      ;; Therefore, the first will be quote.
    #+END_SRC
56. [X] Exercise 2.56
    #+BEGIN_SRC scheme
      ;; Show how to extend the basic differentiator to handle more kinds of
      ;; expressions. For instance, implement the differentiation rule

      ;; d (u ^ n)                     du
      ;; --------- = n (u ^ (n - 1)) -------
      ;;    dx                         dx

      ;; by adding a new clause to the deriv program and defining appropriate
      ;; procedures exponentiation?, base, exponent, and make-exponentiation. (You may
      ;; use the symbol ** to denote exponentiation.) Build in the rules that anything
      ;; raised to the power 0 is 1 and anything raised to the power 1 is the thing
      ;; itself.

      (define (exponentiation? x)
        (and (pair? x) (eq? (car x) '**)))

      (define (base e) (cadr e))

      (define (exponent e) (caddr e))

      (define (make-exponentiation base exp)
        (cond ((=number? base 1) 1)
              ((=number? exp 1) base)
              ((=number? exp 0) 1)
              (else (list '** base exp))))

      (define (variable? x) (symbol? x))

      (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2)))

      (define (=number? exp num)
        (and (number? exp) (= exp num)))

      (define (make-sum a1 a2)
        (cond
         ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2)) (+ a1 a2))
         (else (list '+ a1 a2))))

      (define (make-product m1 m2)
        (cond
         ((or (=number? m1 0) (=number? m2 0)) 0)
         ((=number? m1 1) m2)
         ((=number? m2 1) m1)
         ((and (number? m1) (number? m2)) (* m1 m2))
         (else (list '* m1 m2))))

      (define (sum? x)
        (and (pair? x) (eq? (car x) '+)))

      (define (addend s) (cadr s))

      (define (augend s) (caddr s))

      (define (product? x)
        (and (pair? x) (eq? (car x) '*)))

      (define (multiplier p) (cadr p))

      (define (multiplicand p) (caddr p))

      (define (deriv exp var)
        (cond ((number? exp) 0)
              ((variable? exp)
               (if (same-variable? exp var) 1 0))
              ((sum? exp)
               (make-sum (deriv (addend exp) var)
                         (deriv (augend exp) var)))
              ((product? exp)
               (make-sum
                (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var)
                              (multiplicand exp))))
              ((exponentiation? exp)
               (make-product
                (make-product
                 (exponent exp)
                 (make-exponentiation (base exp)
                                      (make-sum (exponent exp) -1)))
                (deriv (base exp) var)))
              (else
               (error "unknown expression type -- DERIV" exp))))
    #+END_SRC
57. [X] Exercise 2.57
    #+BEGIN_SRC scheme
      ;; Extend the differentiation program to handle sums and products of arbitrary
      ;; numbers of (two or more) terms. Then the last example above could be
      ;; expressed as

      ;; (deriv '(* x y (+ x 3)) 'x)

      ;; Try to do this by changing only the representation for sums and products,
      ;; without changing the deriv procedure at all. For example, the addend of a sum
      ;; would be the first term, and the augend would be the sum of the rest of the
      ;; terms.

      (define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))

      (define (variable? x) (symbol? x))

      (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2)))

      (define (=number? exp num)
        (and (number? exp) (= exp num)))

      (define (make-sum a1 a2)
        (cond
         ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2)) (+ a1 a2))
         (else (list '+ a1 a2))))

      (define (make-product m1 m2)
        (cond
         ((or (=number? m1 0) (=number? m2 0)) 0)
         ((=number? m1 1) m2)
         ((=number? m2 1) m1)
         ((and (number? m1) (number? m2)) (* m1 m2))
         (else (list '* m1 m2))))

      (define (sum? x)
        (and (pair? x) (eq? (car x) '+)))

      (define (addend s) (cadr s))

      (define (augend s)
        (accumulate make-sum 0 (cddr s)))

      (define (product? x)
        (and (pair? x) (eq? (car x) '*)))

      (define (multiplier p) (cadr p))

      (define (multiplicand p)
        (accumulate make-product 1 (cddr  p)))

      (define (deriv exp var)
        (cond ((number? exp) 0)
              ((variable? exp)
               (if (same-variable? exp var) 1 0))
              ((sum? exp)
               (make-sum (deriv (addend exp) var)
                         (deriv (augend exp) var)))
              ((product? exp)
               (make-sum
                (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var)
                              (multiplicand exp))))
              (else
               (error "unknown expression type -- DERIV" exp))))

      (deriv '(* x y (+ x 3)) 'x)
    #+END_SRC
58. [X] Exercise 2.58
    #+BEGIN_SRC scheme
      ;; Suppose we want to modify the differentiation program so that it works with
      ;; ordinary mathematical notation, in which + and * are infix rather than prefix
      ;; operators. Since the differentiation program is defined in terms of abstract
      ;; data, we can modify it to work with different representations of expressions
      ;; solely by changing the predicates, selectors, and constructors that define
      ;; the representation of the algebraic expressions on which the differentiator
      ;; is to operate.

      (define (variable? x) (symbol? x))
      (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2)))
      (define (=number? exp num)
        (and (number? exp) (= exp num)))

      (define (make-sum a1 a2)
        (cond
         ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2)) (+ a1 a2))
         (else (list '+ a1 a2))))
      (define (make-product m1 m2)
        (cond
         ((or (=number? m1 0) (=number? m2 0)) 0)
         ((=number? m1 1) m2)
         ((=number? m2 1) m1)
         ((and (number? m1) (number? m2)) (* m1 m2))
         (else (list '* m1 m2))))
      (define (sum? x)
        (and (pair? x) (eq? (car x) '+)))
      (define (addend s) (cadr s))
      (define (augend s) (caddr s))
      (define (product? x)
        (and (pair? x) (eq? (car x) '*)))
      (define (multiplier p) (cadr p))
      (define (multiplicand p) (caddr p))
      (define (deriv exp var)
        (cond ((number? exp) 0)
              ((variable? exp)
               (if (same-variable? exp var) 1 0))
              ((sum? exp)
               (make-sum (deriv (addend exp) var)
                         (deriv (augend exp) var)))
              ((product? exp)
               (make-sum
                (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var)
                              (multiplicand exp))))
              (else
               (error "unknown expression type -- DERIV" exp))))

      ;; a. Show how to do this in order to differentiate algebraic expressions
      ;; presented in infix form, such as (x + (3 * (x + (y + 2)))). To simplify the
      ;; task, assume that + and * always take two arguments and that expressions are
      ;; fully parenthesized.

      (define (make-sum a1 a2)
        (cond ((=number? a1 0) a2)
              ((=number? a2 0) a1)
              (else (list a1 '+ a2))))

      (define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
      (define (addend s) (car s))
      (define (augend s) (caddr s))

      (define (make-product m1 m2)
        (cond ((=number? m1 1) m2)
              ((=number? m2 1) m1)
              ((or (=number? m1 0) (=number? m2 0)) 0)
              (else (list m1 '* m2))))

      (define (product? x) (and (pair? x) (eq? (cadr x) '*)))
      (define (multiplier x) (car x))
      (define (multiplicand x) (caddr x))

      ;; b. The problem becomes substantially harder if we allow standard algebraic
      ;; notation, such as (x + 3 * (x + y + 2)), which drops unnecessary parentheses
      ;; and assumes that multiplication is done before addition. Can you design
      ;; appropriate predicates, selectors, and constructors for this notation such
      ;; that our derivative program still works?

      ;; I'm just not going to do b...
    #+END_SRC
59. [X] Exercise 2.59
    #+BEGIN_SRC scheme
      ;; Implement the union-set operation for the unordered-list representation of
      ;; sets.

      (define (element-of-set? x set)
        (cond ((null? set) #f)
              ((equal? x (car set)) #t)
              (else (element-of-set? x (cdr set)))))

      (define (adjoin-set x set)
        (if (element-of-set? x set)
            set
            (cons x set)))

      (define (intersection-set set1 set2)
        (cond
         ((or (null? set1) (null? set2)) '())
         ((element-of-set? (car set1) set2)
          (cons (car set1)
                (intersection-set (cdr set1) set2)))
         (else (intersection-set (cdr set1) set2))))

      (define (union-set set1 set2)
        (cond
         ((null? set1) set2)
         (else (union-set (cdr set1) (adjoin-set (car set1) set2)))))
    #+END_SRC
60. [X] Exercise 2.60
    #+BEGIN_SRC scheme
      ;; We specified that a set would be represented as a list with no duplicates.
      ;; Now suppose we allow duplicates. For instance, the set {1,2,3} could be
      ;; represented as the list (2 3 2 1 3 2 2). Design procedures element-of-set?,
      ;; adjoin-set, union-set, and intersection-set that operate on this
      ;; representation. How does the efficiency of each compare with the
      ;; corresponding procedure for the non-duplicate representation? Are there
      ;; applications for which you would use this representation in preference to the
      ;; non-duplicate one?

      (define (element-of-set? x set)
        (cond ((null? set) #f)
              ((equal? x (car set)) #t)
              (else (element-of-set? x (cdr set)))))

      ;; Element of set in unchanged

      (define (adjoin-set x set)
        (cons x set))

      ;; adjoin-set is constant time

      (define (intersection-set set1 set2)
        (cond
         ((or (null? set1) (null? set2)) '())
         ((element-of-set? (car set1) set2)
          (cons (car set1)
                (intersection-set (cdr set1) set2)))
         (else (intersection-set (cdr set1) set2))))

      (define (union-set set1 set2)
        (concat set1 set2))
    #+END_SRC
61. [X] Exercise 2.61
    #+BEGIN_SRC scheme
      ;; Give an implementation of adjoin-set using the ordered representation. By
      ;; analogy with element-of-set? show how to take advantage of the ordering to
      ;; produce a procedure that requires on the average about half as many steps as
      ;; with the unordered representation.

      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (car set)) true)
              ((< x (car set)) false)
              (else (element-of-set? x (cdr set)))))

      (define (adjoin-set x set)
        (cond ((null? set) false)
              ((= x (car set)) set)
              ((< x (car set)) (cons x set))
              (else (cons (car set)
                          (adjoin-set x (cdr set))))))

      (define (intersection-set set1 set2)
        (if (or (null? set1) (null? set2))
            '()
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1
                           (intersection-set (cdr set1)
                                             (cdr set2))))
                    ((< x1 x2)
                     (intersection-set (cdr set1) set2))
                    ((< x2 x1)
                     (intersection-set set1 (cdr set2)))))))
    #+END_SRC
62. [X] Exercise 2.62
    #+BEGIN_SRC scheme
      ;; Give a (n) implementation of union-set for sets represented as ordered lists.

      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (car set)) true)
              ((< x (car set)) false)
              (else (element-of-set? x (cdr set)))))

      (define (adjoin-set x set)
        (cond ((null? set) false)
              ((= x (car set)) set)
              ((< x (car set)) (cons x set))
              (else (cons (car set)
                          (adjoin-set x (cdr set))))))

      (define (intersection-set set1 set2)
        (if (or (null? set1) (null? set2))
            '()
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1
                           (intersection-set (cdr set1)
                                             (cdr set2))))
                    ((< x1 x2)
                     (intersection-set (cdr set1) set2))
                    ((< x2 x1)
                     (intersection-set set1 (cdr set2)))))))

      (define (union-set set1 set2)
        (cond  ((null? set1) set2)
               ((null? set2) set1)
               (else
                (let ((x1 (car set1))
                      (x2 (car set2)))
                  (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                        ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
                        (else (cons x2 (union-set set1 (cdr set2)))))))))
    #+END_SRC
63. [X] Exercise 2.63
    #+BEGIN_SRC scheme
      ;; Each of the following two procedures converts a binary tree to a list.

      (define (entry tree) (car tree))
      (define (left-branch tree) (cadr tree))
      (define (right-branch tree) (caddr tree))
      (define (make-tree entry left right)
        (list entry left right))

      (define (tree->list-1 tree)
        (if (null? tree)
            '()
            (append (tree->list-1 (left-branch tree))
                    (cons (entry tree)
                          (tree->list-1 (right-branch tree))))))

      (define (tree->list-2 tree)
        (define (copy-to-list tree result-list)
          (if (null? tree)
              result-list
              (copy-to-list (left-branch tree)
                            (cons (entry tree)
                                  (copy-to-list (right-branch tree)
                                                result-list)))))
        (copy-to-list tree '()))

      ;; a. Do the two procedures produce the same result for every tree? If not, how
      ;; do the results differ? What lists do the two procedures produce for the trees
      ;; in figure 2.16?

      (define fig2-16-1 '(7 (3 (1 () ()) (5 () ())) (9 () (11 () ()))))
      (define fig2-16-2 '(3 (1 () ()) (7 (5 () ()) (9 () (11 () ())))))
      (define fig2-16-3 '(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))))

      (tree->list-1 fig2-16-1)

      ;; They produce the same result for the three trees from the figure.

      ;; b. Do the two procedures have the same order of growth in the number of steps
      ;; required to convert a balanced tree with n elements to a list? If not, which
      ;; one grows more slowly?

      ;; tree->list-2 grows more slowly, because the append operation is O(n) whereas
      ;; cons is O(1)
    #+END_SRC
64. [X] Exercise 2.64
    #+BEGIN_SRC scheme
      ;; The following procedure list->tree converts an ordered list to a balanced
      ;; binary tree. The helper procedure partial-tree takes as arguments an integer
      ;; n and list of at least n elements and constructs a balanced tree containing
      ;; the first n elements of the list. The result returned by partial-tree is a
      ;; pair (formed with cons) whose car is the constructed tree and whose cdr is
      ;; the list of elements not included in the tree.

      (define (entry tree) (car tree))
      (define (left-branch tree) (cadr tree))
      (define (right-branch tree) (caddr tree))
      (define (make-tree entry left right)
        (list entry left right))

      (define (list->tree elements)
        (car (partial-tree elements (length elements))))

      (define (partial-tree elts n)
        (if (= n 0)
            (cons '() elts)
            (let ((left-size (quotient (- n 1) 2)))
              (let ((left-result (partial-tree elts left-size)))
                (let ((left-tree (car left-result))
                      (non-left-elts (cdr left-result))
                      (right-size (- n (+ left-size 1))))
                  (let ((this-entry (car non-left-elts))
                        (right-result (partial-tree (cdr non-left-elts)
                                                    right-size)))
                    (let ((right-tree (car right-result))
                          (remaining-elts (cdr right-result)))
                      (cons (make-tree this-entry left-tree right-tree)
                            remaining-elts))))))))

      ;; a. Write a short paragraph explaining as clearly as you can how partial-tree
      ;; works. Draw the tree produced by list->tree for the list (1 3 5 7 9 11).

      ;; Partial tree splits the elements into three parts, the median item, the list
      ;; of items less than the median and the list of items greater than the median.
      ;; It creates a binary tree whose root node is the media, the left tree being
      ;; those less called with a recursion, and the right being those that are
      ;; greater called with a recursion.


      ;;    5
      ;;  /   \
      ;; 1     9
      ;;  \   / \
      ;;   3 7  11

      ;; b. What is the order of growth in the number of steps required by list->tree
      ;; to convert a list of n elements?

      ;; O(n)
    #+END_SRC
65. [X] Exercise 2.65
    #+BEGIN_SRC scheme
      ;; Use the results of exercises 2.63 and 2.64 to give (n) implementations of
      ;; union-set and intersection-set for sets implemented as (balanced) binary
      ;; trees.41

      (define remainder mod)
      (define quotient div)

      (define (entry tree) (car tree))
      (define (left-branch tree) (cadr tree))
      (define (right-branch tree) (caddr tree))
      (define (make-tree entry left right)
        (list entry left right))

      (define (tree->list tree)
        (define (copy-to-list tree result-list)
          (if (null? tree)
              result-list
              (copy-to-list (left-branch tree)
                            (cons (entry tree)
                                  (copy-to-list (right-branch tree)
                                                result-list)))))
        (copy-to-list tree '()))

      (define (list->tree elements)
        (car (partial-tree elements (length elements))))

      (define (partial-tree elts n)
        (if (= n 0)
            (cons '() elts)
            (let ((left-size (quotient (- n 1) 2)))
              (let ((left-result (partial-tree elts left-size)))
                (let ((left-tree (car left-result))
                      (non-left-elts (cdr left-result))
                      (right-size (- n (+ left-size 1))))
                  (let ((this-entry (car non-left-elts))
                        (right-result (partial-tree (cdr non-left-elts)
                                                    right-size)))
                    (let ((right-tree (car right-result))
                          (remaining-elts (cdr right-result)))
                      (cons (make-tree this-entry left-tree right-tree)
                            remaining-elts))))))))

      (define (intersection-set-list set1 set2)
        (if (or (null? set1) (null? set2))
            '()
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1
                           (intersection-set-list (cdr set1)
                                                  (cdr set2))))
                    ((< x1 x2)
                     (intersection-set-list (cdr set1) set2))
                    ((< x2 x1)
                     (intersection-set-list set1 (cdr set2)))))))

      (define (union-set-list set1 set2)
        (cond  ((null? set1) set2)
               ((null? set2) set1)
               (else
                (let ((x1 (car set1))
                      (x2 (car set2)))
                  (cond ((= x1 x2) (cons x1 (union-set-list (cdr set1) (cdr set2))))
                        ((< x1 x2) (cons x1 (union-set-list (cdr set1) set2)))
                        (else (cons x2 (union-set-list set1 (cdr set2)))))))))

      (define (union-set tree1 tree2)
        (list->tree (union-set-list (tree->list tree1)
                                    (tree->list tree2))))

      (define (intersection-set tree1 tree2)
        (list->tree (intersection-set-list (tree->list tree1)
                                           (tree->list tree2))))
    #+END_SRC
66. [X] Exercise 2.66
    #+BEGIN_SRC scheme
      ;; Exercise 2.66. Implement the lookup procedure for the case where the set of
      ;; records is structured as a binary tree, ordered by the numerical values of
      ;; the keys.

      (define (entry tree) (car tree))
      (define (left-branch tree) (cadr tree))
      (define (right-branch tree) (caddr tree))
      (define (make-tree entry left right)
        (list entry left right))

      (define (lookup given-key set-of-records)
        (cond ((null? set-of-records) #f)
              ((= given-key (key (entry set-of-records)))
               (entry set-of-records))
              ((< given-key (key (entry set-of-records)))
               (lookup given-key (left-branch set-of-records)))
              (else (lookup given-key (right-branch set-of-records)))))
    #+END_SRC
67. [ ]
68. [ ]
69. [ ]
70. [ ]
71. [ ]
72. [ ]
73. [X]
    + (a) The operations that were specific to the different derivation
      techniques were pulled out into a table. The program now just looks up the
      different techniques and dispatches to the correct entry in the table. We
      can't assimilate /number?/ and /same-variable?/ because they are built-in
      primitives.
    + (b)
      #+BEGIN_SRC scheme
        (define (install-sum-package)
          (define (make-sum a1 a2) (cons a1 a2))
          (define (addend s) (cadr s))
          (define (augend s) (caddr s))
          (define (deriv-sum s)
            (make-sum (deriv (addend s)) (deriv (augend s))))

          (define (tag x) (attach-tag '+ x))
          (put 'deriv '(+) deriv-sum)
          (put 'make-sum '+
               (lambda (x y) (tag (make-sum x y))))
          'done)

        (define (make-sum x y)
          ((get 'make-sum '+) x y))

        (define (install-product-package)
          (define (make-product m1 m2) (cons m1 m2))
          (define (multiplier p) (cadr p))
          (define (multiplicand p) (caddr p))
          (define (deriv-product p)
            (make-sum
             (make-product (multiplier exp)
                           (deriv (multiplicand exp) var))
             (make-product (deriv (multiplier exp) var)
                           (multiplicand exp))))

          (define (tag x) (attach-tag '* x))
          (put 'deriv '(*) deriv-product)
          (put 'make-product '*
               (lambda (x y) (tag (make-product x y))))
          'done)

        (define (make-product x y)
          ((get 'make-product '*) x y))

        (define (deriv x) (apply-generic 'deriv x))
      #+END_SRC
    + (c)
      #+BEGIN_SRC scheme
        (define (exponentation-deriv expr var)
          (make-product (exponent expr)
                        (make-product
                         (make-exponentiation (base expr)
                                              (make-sum (exponent expr) -1))
                         (deriv (base expr) var))))
        (define (exponent expr)
          (cadr expr))
        (define (base expr)
          (car expr))
        (define (make-exponentiation base exponent)
          (cond ((=number? exponent 0) 1)
                ((=number? exponent 1) base)
                ((=number? base 1) 1)
                (else (list '** base exponent))))

        (put 'deriv '** exponentiation-deriv)
      #+END_SRC
    + (d) change the order of arguments for "put"
74. [X]
    + (a)
      #+BEGIN_SRC scheme
        (define (get-record division employee-name)
          ((get division 'record) employee-name))
      #+END_SRC
    + (b)
     #+BEGIN_SRC scheme
       (define (get-salary division record)
         ((get division 'salary) record))
     #+END_SRC
    + (c)
     #+BEGIN_SRC scheme
       (define (find-employee-record employee-name division-list)
         (if (null? division-list)
             #f
             (or (get-record (car division-list) employee-name)
                 (find-employee-record employee-name (cdr division-list)))))
     #+END_SRC
    + (d) the new company needs to install its 'record and 'salary generic
      procedures into the lookup table using its name as the first key.
75. [X]
    #+BEGIN_SRC scheme
      (define (make-from-mag-ang r a)
        (define (dispatch op)
          (cond ((eq? op 'real-part) (* r (cos a)))
                ((eq? op 'imag-part) (* r (sin a)))
                ((eq? op 'magnitude) r)
                ((eq? op 'angle) a)
                (else (error "Unkown op --- MAKE-FROM-MAG-ANG" op))))
        dispatch)
      ((make-from-mag-ang 3 90) 'real-part)
      ((make-from-mag-ang 3 90) 'magnitude)
    #+END_SRC
76. [X] For generic operations with explicit dispatch, adding new operations is
    easy. For message passing, adding new types can be done without changing
    existing code, but adding new operations requires changing all the old code.
    Data directed programming allows new types *and* new operations to be added
    without changing existing code: To add a new type I just fill out a new
    column in the table of operations, to add a new operation I fill out a new
    row.

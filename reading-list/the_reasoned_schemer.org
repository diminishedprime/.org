+ [[../index.org][Main Index]]
+ [[./index.org][Reading List]]

* Reasoned Schemer [20%]
1. [X] Playthings
   #+BEGIN_SRC scheme
     (load "/Users/mjhamrick/Desktop/mjh-org/book-status/the_reasoned_schemer/mk.scm")
     (load "/Users/mjhamrick/Desktop/mjh-org/book-status/the_reasoned_schemer/mkextraforms.scm")

     (define U fail)
     (define S succeed)

     (run* (q) U)

     (run* (q) (== #t q))

     (run* (q)
           U
           (== #t q))

     (run* (q)
           S
           (== #t q))

     (run* (r)
           S
           (== 'corn r))

     (run* (r)
           U
           (== 'corn r))

     (run* (q)
           S
           (== #f q))

     (let ((x #t))
       (== #f x))

     (run* (x)
           (let ((x #t))
             (== #f x)))

     (run* (q)
           (fresh (x)
                  (== #t x)
                  (== #t q)))

     (run* (q)
           (fresh (x)
                  (== x #t)
                  (== #t q)))

     (run* (x)
           S)

     (run* (x)
           (let ((x #f))
             (fresh (x)
                    (== #t x))))

     (run* (r)
           (fresh (x y)
                  (== (cons x (cons y '())) r)))

     (run* (s)
           (fresh (t u)
                  (== (cons t (cons u '())) s)))
     ;; the only difference between this and the previous frame is the
     ;; names of the lexical variables. Therefor the values are the same

     (run* (r)
           (fresh (x)
                  (let ((y x))
                    (fresh (x)
                           (== (cons y (cons x (cons y '()))) r)))))
     ;; within the inner fresh, x and y are different variables and since
     ;; they are still fresh, they get different reified names. Reifying
     ;; r's value reifies the fresh variables in the order in which they
     ;; appear in the list.

     (run* (r)
           (fresh (x)
                  (let ((y x))
                    (fresh (x)
                           (== (cons x (cons y (cons x '()))) r)))))

     ;; same value as above since reifing happens in the order in which
     ;; they appear in the list.

     (run* (q)
           (== #f q)
           (== #t q))
     ;; the first goal succeds, associating #f with q; #t cannot then be
     ;; associated with q, since q is no longer fresh.

     (run* (q)
           (== #f q)
           (== #f q))
     ;; in order for the run to succeed, both (== #f q) and (== #f q) must
     ;; succeed. The first goal succeds while associating #f with the fresh
     ;; variable q. The second goal succeeds beacues although q is no
     ;; longer fresh, #f is already associated with it.

     (run* (q)
           (let ((x q))
             (== #t x)))
     ;; because q and x are the same

     (run* (r)
           (fresh (x)
                  (== x r)))
     ;; _.0 because r starts out fresh and then r gets whatever association
     ;; that x gets, but both x and r remain fresh. When one variable is
     ;; associated with another, we say thay co-refer or share.

     (run* (q)
           (fresh (x)
                  (== #t x)
                  (== x q)))
     ;; because q starts out fresh and then q gets x's association.

     (run* (q)
           (fresh (x)
                  (== x q)
                  (== #t x)))
     ;; because the first goal ensures that whatever association x gets, q
     ;; also gets

     (cond
      (#f #t)
      (else #f))

     (conde
      (U S)
      (else U))
     ;; this fails because the question of the first conde line is the goal
     ;; U

     (conde
      (U U)
      (else S))
     ;; this succeeds. The question of the first conde line is the goal U
     ;; so conde tries the second line which suceeds.

     (conde
      (S S)
      (else U))
     ;; This suceeds because the question of the first conde line is the
     ;; goal S, so conde tries the answer of the first line

     (run* (x)
           (conde
            ((== 'olive x) S)
            ((== 'oil x) S)
            (else U)))
     ;; (olive oil), because (== 'olive x) suceeds; therefore, the answer
     ;; is S. The S preserves the association of x to olive. To get the
     ;; second value, we pretend that (== 'olive x) fails; this imagined
     ;; failure refreshes x. Then (== 'oil x) suceeds. The S preserves the
     ;; association of x to oil. We then pretend that (== oild x) failes,
     ;; which once again refreshes x. Since no more goals suceed, we are
     ;; done.

     (run 1 (x)
          (conde
           ((== 'olive x) S)
           ((== 'oil x) S)
           (else U)))
     ;; because ('olive x) succeeds and because run 1 produces at most one
     ;; value.

     (run* (x)
           (conde
            ((== 'virgin x) U)
            ((== 'olive x) S)
            (S S)
            ((== 'oil x) S)
            (else U)))

     ;; (olive _.0 oil) onci the first conde line fails, it is as if that
     ;; line were not there.

     (run 2 (x)
          (conde
           ((== 'extra x) S)
           ((== 'virgin x) U)
           ((== 'olive x) S)
           ((== 'oil x) S)
           (else U)))
     ;; (extra olive) since we do not want every value, we want only the first two values

     (run* (r)
           (fresh (x y)
                  (== 'split x)
                  (== 'pea y)
                  (== (cons x (cons y '())) r)))

     (run* (r)
           (fresh (x y)
                  (conde
                   ((== 'split x) (== 'pea y))
                   ((== 'navy x) (== 'bean y))
                   (else U))
                  (== (cons x (cons y '())) r)))
     ;; ((split pea) (navy bean))

     (run* (r)
           (fresh (x y)
                  (conde
                   ((== 'split x) (== 'pea y))
                   ((== 'navy x) (== 'bean y))
                   (else U))
                  (== (cons x (cons y (cons 'soup '()))) r)))
     ;; ((split pea soup) (navy bean soup))

     (define teacup-o
       (lambda (x)
         (conde
          ((== 'tea x) S)
          ((== 'cup x) S)
          (else U))))
     (run* (x)
           (teacup-o x))
     ;; (tea cup)

     (run* (r)
           (fresh (x y)
                  (conde
                   ((teacup-o x) (== #t y) S)
                   ((== #f x) (== #t y))
                   (else U))
                  (== (cons x (cons y '())) r)))
     ;; ((tea #t) (cup #t) (#f #t))

     (run* (r)
           (fresh (x y z)
                  (conde
                   ((== y x) (fresh (x) (== z x)))
                   ((fresh (x) (== y x)) (== z x))
                   (else U))
                  (== (cons y (cons z '())) r)))
     ;; ((_.0 _.1) (_.0 _.1))

     (run* (r)
           (fresh (x y z)
                  (conde
                   ((== y x) (fresh (x) (== z x)))
                   ((fresh (x) (== y x)) (== z x))
                   (else U))
                  (== #f x)
                  (== (cons y (cons z '())) r)))
     ;; ((#f _.0) (_.0 #f)) this clearly shows that the two occurrences of
     ;; _0 in the previous frame represent different variables.

     (run* (q)
           (let ((a (== #t q))
                 (b (== #f q)))
             b))
     ;; (#f) which shows that (== #t q) and (== #f q) are expressions, each
     ;; of whose value is a goal. But, here we only treat the (== #f q)
     ;; expressions value, b, as a goal.

     (run* (q)
           (let ((a (== #t q))
                 (b (fresh (x)
                           (== x q)
                           (== #f x)))
                 (c (conde
                     ((== #t q) S)
                     (else (== #f q)))))
             b))
     ;; (#f), which shows that (== ...), (fresh ...), and (conde ...) are
     ;; expressions, each of whose value is a goal. But, here, we only
     ;; treat the fresh expressions value, b, as a goal. This is indeed
     ;; interesting.

     ;; JAMS STAINS AND STUFF!!!





     #+END_SRC
2. [X] Teaching Old Toys New Tricks
    #+BEGIN_SRC scheme
    (load "/Users/mjhamrick/.org/reading-list/the_reasoned_schemer/mk.scm")
      (load "/Users/mjhamrick/.org/reading-list/the_reasoned_schemer/mkextraforms.scm")

      (let ((x (lambda (a) a))
            (y 'c))
        (x y))

      (run* (r)
            (fresh (y x)
                   (== `(,x ,y) r)))

      (run* (r)
            (fresh (v w)
                   (== (let ((x v)
                             (y w))
                         `(,x ,y))
                       r)))

      (car `(grape raisin pear))

      (car `(a c o r n))
      ;; Haven't defined caro yet... That's why it doesn't work.
      (define caro
        (lambda (p a)
          (fresh (d)
                 (== (cons a d) p))))
      (run* (r)
            (fresh ())
            (caro `(a c o r n) r))


      (run* (q)
            (caro `(a c o r n) 'a)
            (== #t q))

      (run* (r)
            (fresh (x y)
                   (caro `(,r ,y) x)
                   (== 'pear x)))

      (cons
       (car `(grape raison pear))
       (car `((a) (b) (c))))

      (run* (r)
            (fresh (x y)
                   (caro `(grape raisin pear) x)
                   (caro `((a) (b) (c)) y)
                   (== (cons x y) r)))

      (cdr `(grape raisin pear))

      (car (cdr `(a c o r n)))

      (define cdro
        (lambda (p d)
          (fresh (a)
                 (== (cons a d) p))))

      (run* (r)
            (fresh (v)
                   (cdro `(a c o r n) v)
                   (caro v r)))

      (cons
       (cdr `(grape raisin pear))
       (car `((a) (b) (c))))

      (run* (r)
            (fresh (x y)
                   (cdro `(grape raisin pear) x)
                   (caro `((a) (b) (c)) y)
                   (== (cons x y) r)))

      (run* (q)
            (cdro `(a c o r n) `(c o r n))
            (== #t q))

      (run* (x)
            (cdro `(c o r n) `(,x r n)))

      (run* (l)
            (fresh (x)
                   (cdro l `(c o r n))
                   (caro l x)
                   (== 'a x)))

      (define conso
        (lambda (a d p)
          (== (cons a d) p)))

      (run* (l)
            (conso `(a b c) `(d e) l))

      (run* (r)
            (fresh (x y z)
                   (== `(e a d ,x) r)
                   (conso y `(a ,z c) r)))

      (run* (x)
            (conso x `(a ,x c) `(d a ,x c)))

      (run* (l)
            (fresh (x)
                   (== `(d a ,x c) l)
                   (conso x `(a ,x c) l)))

      (run* (l)
            (fresh (d x y w s)
                   (conso w `(a n s) s)
                   (cdro l s)
                   (caro l x)
                   (== 'b x)
                   (cdro l d)
                   (caro d y)
                   (== 'e y)))

      (null? `(grape raisin pear))

      (null? `())

      (define nullo
        (lambda (x)
          (== `() x)))

      (run* (q)
            (nullo `(grape raisin pear))
            (== #t q))

      (run* (q)
            (nullo `())
            (== #t q))

      (run* (x)
            (nullo x))

      (eq? 'pear 'plum)

      (eq? 'plum 'plum)

      (define eqo
        (lambda (x y)
          (== x y)))

      (run* (q)
            (eqo 'pear 'plum)
            (== #t q))

      (run* (q)
            (eqo 'plum 'plum)
            (== #t q))

      `(split . pea)

      (pair? `((split) . pea))

      (pair? `())

      (pair? `(pear))

      (cdr `(pear))

      (cons `(split) 'pea)

      (run* (r)
            (fresh (x y)
                   (== (cons x (cons y 'salad)) r)))

      (define pairo
        (lambda (p)
          (fresh (a d)
                 (conso a d p))))

      (run* (q)
            (pairo (cons q q))
            (== #t q))

      (run* (q)
            (pairo `())
            (== #t q))

      (run* (q)
            (pairo 'pair)
            (== #t q))

      (run* (x)
            (pairo x))

      (run* (r)
            (pairo (cons r 'pear)))
    #+END_SRC
3. [ ] Seeing Old Friends in New Ways
   #+BEGIN_SRC scheme
     (load "/Users/mjhamrick/.org/reading-list/the_reasoned_schemer/mk.scm")
     (load "/Users/mjhamrick/.org/reading-list/the_reasoned_schemer/mkextraforms.scm")
     (load "/Users/mjhamrick/.org/reading-list/the_reasoned_schemer/previous_chapters.scm")

     (define list?
       (lambda (l)
         (cond
          ((null? l) #t)
          ((pair? l) (list? (cdr l)))
          (else #f))))

     (list? `())

     (list? 's)

     (list? `(d a t e . s))

     (define listo
       (lambda (l)
         (conde
          ((nullo l) S)
          ((pairo l) (fresh (d)
                            (cdro l d)
                            (listo d)))
          (else U))))

     (run* (x)
           (listo `(a b ,x d)))

     (run 1 (x)
          (listo `(a b c . ,x)))

     (run 5 (x)
          (listo `(a b c . ,x)))

     (define lol?
       (lambda (l)
         (cond
          ((null? l) #t)
          ((list? (car l)) (lol? (cdr l)))
          (else #f))))

     (define lolo
       (lambda (l)
         (conde
          ((nullo l) S)
          ((fresh (a)
                  (caro l a)
                  (listo a)) (fresh (d)
                                    (cdro l d)
                                    (lolo d)))
          (else U))))

     (run 1 (l)
          (lolo l))

     (run* (q)
           (fresh (x y)
                  (lolo `((a b) (,x c) (d ,y)))
                  (== #t q)))

     (run 1 (q)
          (fresh (x)
                 (lolo `((a b) . ,x))
                 (== #t q)))

     (run 1 (x)
          (lolo `((a b) (c d) . ,x)))

     (run 5 (x)
          (lolo `((a b) (c d) . ,x)))

     (define twinso
       (lambda (s)
         (fresh (x y)
                (conso x y s)
                (conso x `() y))))

     (run* (q)
           (twinso `(tofu tofu))
           (== #t q))

     (run* (z)
           (twinso `(,z tofu)))

     (define twinso
       (lambda (s)
         (fresh (x)
                (== `(,x ,x) s))))

     (run* (q)
           (twinso `(tofu tofu))
           (== #t q))

     (run* (z)
           (twinso `(,z tofu)))

     (define loto
       (lambda (l)
         (conde
          ((nullo l) S)
          ((fresh (a)
                  (caro l a)
                  (twinso a)) (fresh (d)
                                     (cdro l d)
                                     (loto d)))
          (else U))))

     (run 1 (z)
          (loto `((g g) . ,z)))

     (run 5 (z)
          (loto `((g g) . ,z)))

     (run 5 (r)
          (fresh (w x y z)
                 (loto `((g g) (e ,w) (,x ,y) . ,z))
                 (== `(,w (,x ,y) ,z) r)))

     (run 3 (out)
          (fresh (w x y z)
                 (== `((g g) (e ,w) (,x ,y) . ,z) out)
                 (loto out)))

     (define listofo
       (lambda (predo l)
         (conde
          ((nullo l) S)
          ((fresh (a)
                  (caro l a)
                  (predo a)) (fresh (d)
                                    (cdro l d)
                                    (listofo predo d)))
          (else U))))

     (run 3 (out)
          (fresh (w x y z)
                 (== `((g g) (e ,w) (,x ,y) . ,z) out)
                 (listofo twinso out)))

     (define loto
       (lambda (l)
         (listofo twino l)))

     (define eq-car?
       (lambda (l x)
         (eq? (car l) x)))

     (define member?
       (lambda (x l)
         (cond
          ((null? l) #f)
          ((eq-car? l x) #t)
          (else (member? x (cdr l))))))

     (member? 'olive '(virgin olive oil))

     (define eq-caro
       (lambda (l x)
         (caro l x)))

     (define membero
       (lambda (x l)
         (conde
          ((nullo l) U)
          ((eq-caro l x) S)
          (else (fresh (d)
                       (cdro l d)
                       (membero x d))))))

     (run* (q)
           (membero 'olive `(virgin olive oil))
           (== #t q))

     (run 1 (y)
          (membero y `(hummus with pita)))

     (run 1 (y)
          (membero y `(with pita)))

     (run 1 (y)
          (membero y `(pita)))

     (run 1 (y)
          (membero y `()))

     (run* (y)
           (membero y `(hummus with pita)))

     (define identity
       (lambda (l)
         (run* (y)
               (membero y l))))

     (run* (x)
           (membero 'e `(pasta ,x fagioli)))

     (run 1 (x)
          (membero 'e `(pasta e ,x fagioli)))

     (run 1 (x)
          (membero 'e `(pasta ,x e fagioli)))

     (run* (r)
           (fresh (x y)
                  (membero 'e `(pasta ,x fagioli ,y))
                  (== `(,x ,y) r)))

     (run 1 (l)
          (membero 'tofu l))

     (run 5 (l)
          (membero 'tofu l))

     (define pmembero
       (lambda (x l)
         (conde
          ((nullo l) U)
          ((eq-caro l x) (cdro l `()))
          (else (fresh (d)
                       (cdro l d)
                       (pmembero x d))))))

     (run 5 (l)
          (pmembero 'tofu l))

     (run* (q)
           (pmembero 'tofu `(a b tofu d tofu))
           (== #t q))

     (define pmembero
       (lambda (x l)
         (conde
          ((nullo l) U)
          ((eq-caro l x) (cdro l `()))
          ((eq-caro l x) S)
          (else (fresh (d)
                       (cdro l d)
                       (pmembero x d))))))

     (run* (q)
           (pmembero 'tofu `(a b todu d tofu))
           (== #t q))

     (define pmembero
       (lambda (x l)
         (conde
          ((nullo l) U)
          ((eq-caro l x) (cdro l `()))
          ((eq-caro l x) (fresh (a d)
                                (cdro l `(,a . ,d))))
          (else (fresh (d)
                       (cdro l d)
                       (pmembero x d))))))

     (run* (q)
           (pmembero 'tofu `(a b todu d tofu))
           (== #t q))

     (run 12 (l)
          (pmembero 'tofu l))

     (define pmembero
       (lambda (x l)
         (conde
          ((eq-caro l x) (fresh (a d)
                                (cdro l `(,a . ,d))))
          ((eq-caro l x) (cdro l `()))
          (else (fresh (d)
                       (cdro l d)
                       (pmembero x d))))))

     (run 12 (l)
          (pmembero 'tofu l))


     (define first-value
       (lambda (l)
         (run 1 (y)
              (membero y l))))

     (first-value `(pasta e fagioli))

     (define memberrevo
       (lambda (x l)
         (conde
          ((nullo l) U)
          (S (fresh (d)
                    (cdro l d)
                    (memberrevo x d)))
          (else (eq-caro l x)))))

     (run* (x)
           (memberrevo x `(pasta e fagioli)))

     (define reverse-list
       (lambda (l)
         (run* (y)
               (memberorevo y l))))

   #+END_SRC
4. [ ] Members Only
5. [ ] Double Your Fun
6. [ ] The Fun Never Ends
7. [ ] A Bit Too Much
8. [ ] Just a Bit More
9. [ ] Under the Hood
10. [ ] Thin Ice

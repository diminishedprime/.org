+ [[../index.org][Main Index]]
+ [[./index.org][Reading List]]

* Haskell Book [48%]
1. [X] All You Need Is Lambda [100%]
   1. [X] All You Need Is Lambda
   2. [X] What's A Function
   3. [X] Lotsa Lambdas
   4. [X] Beta Reduction
   5. [X] Bound And Free Variables
   6. [X] Alpha Equivalence
   7. [X] Multiple Arguments
   8. [X] Evaluation is Simplification
   9. [X] Combinators
   10. [X] Divergence
   11. [X] Summary
   12. [X] [[./haskell_programming_from_first_principles/01.12.hs][Exercises]]
   13. [X] Answers
   14. [X] Definitions
   15. [X] Follow-up resources.
2. [X] Hello Haskell [100%]
   1. [X] Hello Haskell
   2. [X] Interacting with Haskell Code
   3. [X] Understanding Expressions
   4. [X] Functions - [[./haskell_programming_from_first_principles/02_04.lhs][Exercises]]
   5. [X] Infix Operators - [[./haskell_programming_from_first_principles/02_05.lhs][Exercises]]
   6. [X] Declaring Values [[./haskell_programming_from_first_principles/02_06.lhs][Exercises]]
   7. [X] Arithmetic functions in Haskell
   8. [X] Negative Numbers
   9. [X] Parenthesizing infix functions
   10. [X] Laws for quotients and remainders
   11. [X] Evaluation
   12. [X] Let and Where [[./haskell_programming_from_first_principles/02_12.hs][Exercises]]
   13. [X] [[./haskell_programming_from_first_principles/02_13.hs][Exercises]]
   14. [X] Definitions
   15. [X] Follow-up resources.
3. [X] Strings [100%]
   1. [X] Printing Strings
   2. [X] A first look at types
   3. [X] Printing simple strings [[./haskell_programming_from_first_principles/03_03.hs][Exercises]]
   4. [X] Types of concatenation functions [[./haskell_programming_from_first_principles/03_04.hs][Exercises]]
   5. [X] Concatenation and scoping
   6. [X] More List Functions
   7. [X] [[./haskell_programming_from_first_principles/03_07.hs][Chapter Exercises]]
   8. [X] Definitions
4. [X] Basic Datatypes[100%]
   1. [X] Basic Datatypes
   2. [X] [[./haskell_programming_from_first_principles/04_02.hs][Anatomy of a data declaration]]
   3. [X] Numeric Types
   4. [X] [[./haskell_programming_from_first_principles/04_04.hs][Comparing Values]]
   5. [X] Tuples
   6. [X] Lists
   7. [X] [[./haskell_programming_from_first_principles/04_07.hs][Chapter Exercises]]
   8. [X] Definitions
   9. [X] Answers
5. [X] Types [100%]
   1. [X] Types
   2. [X] What are Types?
   3. [X] Querying and Reading Types
   4. [X] Typeclass constrained type variables [[./haskell_programming_from_first_principles/05_04.hs][Intermission: Exercises]]
   5. [X] Currying [[./haskell_programming_from_first_principles/05_05.hs][Intermission: Exercises]]
   6. [X] Polymorphism [[./haskell_programming_from_first_principles/05_06.hs][Intermission: Exercises]]
   7. [X] [[./haskell_programming_from_first_principles/05_07.hs][Type Inference]]
   8. [X] Asserting Types for declarations
   9. [X] [[./haskell_programming_from_first_principles/05_09.hs][Chapter Exercises]]
   10. [X] Definitions
   11. [X] Follow-up resources
6. [X] Typeclasses [100%]
   1. [X] Typeclasses
   2. [X] What are type classes?
   3. [X] Back to Bool
   4. [X] Eq
   5. [X] Num
   6. [X] Type-defaulting typeclasses
   7. [X] [[./haskell_programming_from_first_principles/06_07.hs][Ord]]
   8. [X] Enum
   9. [X] Show
   10. [X] Read
   11. [X] Instances are dispatched by type
   12. [X] [[./haskell_programming_from_first_principles/06_12.hs][Writing typeclass instances]]
   13. [X] Gimme more operations
   14. [X] [[./haskell_programming_from_first_principles/06_14.hs][Chapter Exercises]]
   15. [X] Chapter Definitions
   16. [X] Typeclass inheritance, partial
   17. [X] Follow-up resources
7. [X] More functional patterns [100%]
   1. [X] Make it func-y
   2. [X] Arguments and parameters
   3. [X] [[./haskell_programming_from_first_principles/07_03.hs][Anonymous functions]]
   4. [X] [[./haskell_programming_from_first_principles/07_04.hs][Pattern matching]]
   5. [X] [[./haskell_programming_from_first_principles/07_05.hs][Case expressions]]
   6. [X] [[./haskell_programming_from_first_principles/07_06.hs][Higher-order functions]]
   7. [X] [[./haskell_programming_from_first_principles/07_07.hs][Guards]]
   8. [X] Function composition
   9. [X] Point-free style
   10. [X] Demonstrating composition
   11. [X] [[./haskell_programming_from_first_principles/07_11.hs][Chapter Exercises]]
   12. [X] Chapter Definitions
   13. [X] Follow-up resources
8. [X] Recursion [100%]
   1. [X] Recursion
   2. [X] Factorial
   3. [X] Bottom
   4. [X] Fibonacci Numbers
   5. [X] Integral division from scratch
   6. [X] [[./haskell_programming_from_first_principles/08_06.hs][Exercises]]
   7. [X] Definitions
9. [X] Lists [100%]
   1. [X] Lists
   2. [X] The List Datatype
   3. [X] Pattern Matching on Lists
   4. [X] List's syntatic sugar
   5. [X] [[./haskell_programming_from_first_principles/09_05.hs][Using ranges to construct Lists]]
   6. [X] [[./haskell_programming_from_first_principles/09_06.hs][Extractating portions of lists]]
   7. [X] [[./haskell_programming_from_first_principles/09_07.hs][List Comprehensions]]
   8. [X] [[./haskell_programming_from_first_principles/09_08.hs][Spines and non-strict evaluation]]
   9. [X] [[./haskell_programming_from_first_principles/09_09.hs][Transforming lists of values]]
   10. [X] [[./haskell_programming_from_first_principles/09_10.hs][Filtering Lists of Values]]
   11. [X] [[./haskell_programming_from_first_principles/09_11.hs][Zipping Lists]]
   12. [X] [[./haskell_programming_from_first_principles/09_12.hs][Chapter Exercises]]
   13. [X] Definitions
   14. [X] Follow-up Resources
10. [X] Folding Lists [100%]
    1. [X] Folds
    2. [X] Bringing you into the fold
    3. [X] Recursive Patterns
    4. [X] Fold Right
    5. [X] [[./haskell_programming_from_first_principles/10_05.hs][Fold Left]]
    6. [X] [[./haskell_programming_from_first_principles/10_06.hs][How To Write Fold Functions]]
    7. [X] Folding and evaluation
    8. [X] Summary
    9. [X] [[./haskell_programming_from_first_principles/10_09.hs][Scans]]
    10. [X] [[./haskell_programming_from_first_principles/10_10.hs][Chapter Exercises]]
    11. [X] Definitions
    12. [X] Answers
    13. [X] Follow-up Resources
11. [X] Algebraic Datatypes [100%]
    1. [X] Algebraic Datatypes
    2. [X] Data declarations review
    3. [X] Data and type constructors
    4. [X] [[./haskell_programming_from_first_principles/11_04.hs][Data constructors and values]]
    5. [X] [[./haskell_programming_from_first_principles/11_05.hs][What's a type and what's data?]]
    6. [X] Data constructor arities
    7. [X] [[./haskell_programming_from_first_principles/11_07.hs][What makes these datatypes algebraic?]]
    8. [X] [[./haskell_programming_from_first_principles/11_08.hs][Sum types]]
    9. [X] [[./haskell_programming_from_first_principles/11_09.hs][Product types]]
    10. [X] [[./haskell_programming_from_first_principles/11_10.hs][Normal form]]
    11. [X] [[./haskell_programming_from_first_principles/11_11.hs][Constructing and deconstructing values]]
    12. [X] [[./haskell_programming_from_first_principles/11_12.hs][Function type is exponential]]
    13. [X] Higher-kinded data types
    14. [X] Lists are Polymorphic
    15. [X] [[./haskell_programming_from_first_principles/11_15.hs][Binary Tree]]
    16. [X] [[./haskell_programming_from_first_principles/11_16.hs][Chapter Exercises]
    17. [X] Definitions
    18. [X] Answers
12. [X] Signaling adversity [100%]
    1. [X] Signaling adversity
    2. [X] How I learned to stop worrying and love Nothing
    3. [X] Bleating either
    4. [X] Kinds, a thousand stars in your types
    5. [X] [[./haskell_programming_from_first_principles/12_06.hs][Chapter Exercises]
    6. [X] Definitions
13. [X] Building projects [100%]
    1. [X] Module
    2. [X] Making Packages With Stack
    3. [X] Working with a Base Project
    4. [X] Executable Stanzas in Cabal files
    5. [X] Making A Project Library
    6. [X] Module Exports
    7. [X] More on importing Modules
    8. [X] Making our Program Interactive
    9. [X] do syntax and IO
    10. [X] Hangman game
    11. [X] Step One: Importing Modules
    12. [X] Step Two: Generating a word list
    13. [X] Step Three: Making a puzzle
    14. [X] Adding a Newtype
    15. [X] [[./haskell_programming_from_first_principles/13_15.hs][Chapter Exercises]]
    16. [X] Follow-up Resources
14. [-] Testing [37%]
    1. [X] Testing
    2. [X] A quick tour of testing for the uninitiated
    3. [X] Conventional Testing
    4. [ ] Enter QuickCheck
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
15. [-] Monoid, Semigroup [93%]
    1. [X]  Monoids and semigroups
    2. [X]  What we talk about when we talk about algebras
    3. [X]  Monoid
    4. [X]  How Monoid is defined in Haskell
    5. [X]  Examples of using Monoid
    6. [X]  Why Integer doesn’t have a Monoid
    7. [X]  Why bother?
    8. [X]  Laws
    9. [X]  Different typeclass instance, same representation
    10. [X]  [[./haskell_programming_from_first_principles/15_10.hs][Reusing algebras by asking for algebras]]
    11. [X]  [[./haskell_programming_from_first_principles/15_11.hs][Madness]]
    12. [X]  [[./haskell_programming_from_first_principles/15_12.hs][Better living through QuickCheck]]
    13. [X]  Semigroup
    14. [ ]  [[./haskell_programming_from_first_principles/15_14.hs][Chapter exercises]]
    15. [X]  Definitions
    16. [X]  Follow-up resources
16. [X] Functor [100%]
    1. [X] Functor
    2. [X] What’s a functor?
    3. [X] There’s a whole lot of fmap going round
    4. [X] [[./haskell_programming_from_first_principles/16_04.hs][Let’s talk about f, baby]]
    5. [X] Functor Laws
    6. [X] The Good, the Bad, and the Ugly
    7. [X] [[./haskell_programming_from_first_principles/16_07.hs][Commonly used functors]]
    8. [X] Mapping over the structure to transform the unapplied type argument
    9. [X] QuickChecking Functor instances
    10. [X] [[./haskell_programming_from_first_principles/16_10.hs][Intermission: Exercises]]
    11. [X] [[./haskell_programming_from_first_principles/16_11.hs][Ignoring possibilities]]
    12. [X] A somewhat surprising functor
    13. [X] More structure, more functors
    14. [X] IO Functor
    15. [X] What if we want to do something different?
    16. [X] Functors in Haskell are unique for a given datatype
    17. [X] [[./haskell_programming_from_first_principles/16_17.hs][Chapter exercises]]
    18. [X] Definitions
    19. [X] Follow-up resources
17. [X] Applicative [100%]
    1. [X] Applicative
    2. [X] Defining Applicative
    3. [X] Functor vs. Applicative
    4. [X] Applicative functors are monoidal functors
    5. [X] [[./haskell_programming_from_first_principles/17_05.hs][Applicative in Use]]
    6. [X] Applicative Laws
    7. [X] You Knew This Was Coming
    8. [X] [[./haskell_programming_from_first_principles/17_08.hs][ZipList Monoid]]
    9. [X] [[./haskell_programming_from_first_principles/17_09.hs][Chapter Exercises]]
    10. [X] Definitions
    11. [X] Follow-up Resources
    12. [X] Answers
18. [-] Monad [33%]
    1. [X] Monad
    2. [X] [[./haskell_programming_from_first_principles/18_02.hs][Sorry -- Monad is not a burrito]]
    3. [X] Do syntax and monads
    4. [ ] Examples of Monad use
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
19. [ ] Applying structure 738 [0%]
    1. [ ]  Appliedstructure .......................739
    2. [ ]  Monoid..............................739
    3. [ ]  Functor..............................743
    4. [ ]  Applicative............................746
    5. [ ]  Monad ..............................749
    6. [ ]  An end-to-end example: URL shortener . . . . . . . . 751
    7. [ ]  That’sawrap!.......................... 761
    8. [ ]  Follow-upresources...................... 762
20. [ ] Foldable 763 [0%]
    1. [ ]  Foldable .............................764
    2. [ ]  TheFoldableclass.......................764
    3. [ ]  Revengeofthemonoids...................765
    4. [ ]  DemonstratingFoldableinstances . . . . . . . . . . . . 768
    5. [ ]  Somebasicderivedoperations...............771
    6. [ ]  ChapterExercises .......................775
    7. [ ]  Answers.............................. 776
    8. [ ]  Follow-upresources...................... 776
21. [ ] Traversable 777 [0%]
    1. [ ]  Traversable ...........................778
    2. [ ]  The Traversable typeclass definition . . . . . . . . . . . 778
    3. [ ]  sequenceA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 779
    4. [ ]
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
    10. [ ]
    11. [ ]
    12. [ ]
    13. [ ]
22. [ ] Reader [0%]
    1. [ ]
    2. [ ]
    3. [ ]
    4. [ ]
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
    10. [ ]
    11. [ ]
    12. [ ]
23. [ ] State [0%]
    1. [ ]
    2. [ ]
    3. [ ]
    4. [ ]
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
24. [ ] Parser combinators 840 [0%]
    1. [ ]  Parsercombinators ......................841
    2. [ ]  Afewmorewordsofintroduction . . . . . . . . . . . . 842
    3. [ ]  Understandingtheparsingprocess . . . . . . . . . . . . 842
    4. [ ]  Parsingfractions........................852
    5. [ ]  Haskell’sparsingecosystem.................857
    6. [ ]  Alternative............................860
    7. [ ]  Parsingconfigurationfiles..................868
25. [ ] Composing types 900 [0%]
    1. [ ]  Composingtypes .......................901
    2. [ ]  Commonfunctionsastypes ................902
    3. [ ]  Two little functors sittin’ in a tree,L-I-F-T-I-N-G . . . . . . . . . . . . . . . . . . . . . . . . . . 904
    4. [ ]  Twinplicative ..........................906
    5. [ ]  Twonad? .............................907
    6. [ ]  Intermission:Exercises....................908
    7. [ ]  Monadtransformers .....................909
    8. [ ]  IdentityT............................. 911
    9. [ ]  Findingapattern........................ 921
    10. [ ]  Answers.............................. 923
26. [ ] Monad transformers 926 [0%]
    1. [ ]  Monadtransformers .....................927
    2. [ ]  MaybeT .
    3. [ ]  EitherT .
    4. [ ]  ReaderT
    5. [ ]  StateT . .
    6. [ ]  Typesyouprobablydon’twanttouse . . . . . . . . . . 937
    7. [ ]  Recovering the ordinary type from the transformer . 938
    8. [ ]  Lexicallyinnerisstructurallyouter. . . . . . . . . . . . 939
    9. [ ]  MonadTrans...........................941
    10. [ ]  MonadIOakazoom-zoom .................952
    11. [ ]  Monadtransformersinuse .................954
    12. [ ]  Monadsdonotcommute ..................962
    13. [ ]  Transformifyouwantto ..................962
    14. [ ]  ChapterExercises .......................963
    15. [ ]  Answers.............................. 969
    16. [ ]  Follow-upresources...................... 969
27. [ ] Non-strictness 970 [0%]
    1. [ ]  Laziness .............................971
    2. [ ]  ObservationalBottomTheory...............972
    3. [ ]  Outsidein,insideout.....................972
    4. [ ]  Whatdoestheotherwaylooklike? . . . . . . . . . . . . 975
    5. [ ]  Callbyname,callbyneed..................986
    6. [ ]  Non-strict evaluation changes what we can do . . . . . 987
    7. [ ]  Thunk Life . . . . . . . . . . . . . . . . . . . . . . . . . . . . 988
    8. [ ]  Sharing is caring . . . . . . . . . . . . . . . . . . . . . . . . 990
    9. [ ]  Refutableandirrefutablepatterns . . . . . . . . . . . . 1002
    10. [ ]  Bang-patterns . . . . . . . . . . . . . . . . . . . . . . . . . . 1004
    11. [ ]  Strict and StrictData . . . . . . . . . . . . . . . . . . . . . . 1007
    12. [ ]  Adding strictness . . . . . . . . . . . . . . . . . . . . . . . . 1008
    13. [ ]  ChapterExercises .......................1012
    14. [ ]  Follow-upresources...................... 1014
28. [ ] Basic libraries 1015 [0%]
    1. [ ]
    2. [ ]
    3. [ ]
    4. [ ]
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
    10. [ ]
    11. [ ]
29. [ ] IO [0%]
    1. [ ]
    2. [ ]
    3. [ ]
    4. [ ]
    5. [ ]
    6. [ ]
    7. [ ]
    8. [ ]
    9. [ ]
    10. [ ]
30. [ ] When things go wrong 1066 [0%]
    1. [ ]  Exceptions............................ 1067
    2. [ ]  TheExceptionclassandmethods . . . . . . . . . . . . . 1067
    3. [ ]  Thismachinekillsprograms ................1073
    4. [ ]  Wanteither?Try! .......................1077
    5. [ ]  The unbearable imprecision of trying . . . . . . . . . . 1080
    6. [ ]  WhythrowIO? .........................1082
    7. [ ]  Makingourownexceptiontypes . . . . . . . . . . . . . 1084
    8. [ ]  Laziness combined with bottom might surprise you . 1088
    9. [ ]  Asynchronous Exceptions . . . . . . . . . . . . . . . . . . 1089
    10. [ ]  Follow-upReading ......................1093
31. [ ] Final project 1094 [0%]
    1. [ ]  Finalproject...........................1095
    2. [ ]  fingerd ..............................1095
    3. [ ]  Exploringfinger ........................1096
    4. [ ]  Slightlymodernizedfingerd ................1101
    5. [ ]  Chapter-Exercises .......................1108
